<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<link rel="Start" href="index.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Cash" rel="Chapter" href="Cash.html"><link title="Process notation" rel="Section" href="#1_Processnotation">
<link title="System calls" rel="Section" href="#syscalls">
<link title="Networking" rel="Section" href="#1_Networking">
<link title="Strings and characters" rel="Section" href="#1_Stringsandcharacters">
<link title="Reading delimited strings" rel="Section" href="#rdelim">
<link title="Record I/O and field parsing" rel="Section" href="#record_io_and_field_parsing">
<link title="Running Cash" rel="Section" href="#1_RunningCash">
<link title="Copyright & source-code license" rel="Subsection" href="#2_Copyrightsourcecodelicense">
<link title="Caveats" rel="Subsection" href="#2_Caveats">
<link title="Naming conventions" rel="Subsection" href="#2_Namingconventions">
<link title="A word about Unix standards" rel="Subsection" href="#2_AwordaboutUnixstandards">
<link title="Procedures and syntax extensions" rel="Subsection" href="#2_Proceduresandsyntaxextensions">
<link title="Interfacing process output to Caml" rel="Subsection" href="#2_InterfacingprocessoutputtoCaml">
<link title="More complex process operations" rel="Subsection" href="#2_Morecomplexprocessoperations">
<link title="Multiple stream capture" rel="Subsection" href="#2_Multiplestreamcapture">
<link title="Process filters" rel="Subsection" href="#2_Processfilters">
<link title="Errors" rel="Subsection" href="#2_Errors">
<link title="I/O" rel="Subsection" href="#gen_io">
<link title="File system" rel="Subsection" href="#2_Filesystem">
<link title="Directories, globbing and temp files" rel="Subsection" href="#2_Directoriesglobbingandtempfiles">
<link title="Processes" rel="Subsection" href="#2_Processes">
<link title="Process state" rel="Subsection" href="#2_Processstate">
<link title="User and group database access" rel="Subsection" href="#2_Userandgroupdatabaseaccess">
<link title="Accessing command-line arguments" rel="Subsection" href="#2_Accessingcommandlinearguments">
<link title="System parameters" rel="Subsection" href="#2_Systemparameters">
<link title="Signal system" rel="Subsection" href="#2_Signalsystem">
<link title="Time" rel="Subsection" href="#time_date">
<link title="Environment variables" rel="Subsection" href="#2_Environmentvariables">
<link title="Terminal device control" rel="Subsection" href="#2_Terminaldevicecontrol">
<link title="Sockets" rel="Subsection" href="#2_Sockets">
<link title="Socket addresses" rel="Subsection" href="#2_Socketaddresses">
<link title="High-level interface" rel="Subsection" href="#2_Highlevelinterface">
<link title="Socket primitives" rel="Subsection" href="#2_Socketprimitives">
<link title="Performing input and output on sockets" rel="Subsection" href="#2_Performinginputandoutputonsockets">
<link title="Socket options" rel="Subsection" href="#2_Socketoptions">
<link title="Database-information entries" rel="Subsection" href="#2_Databaseinformationentries">
<link title="Manipulating file names" rel="Subsection" href="#filenames">
<link title="Reading records" rel="Subsection" href="#2_Readingrecords">
<link title="Parsing fields" rel="Subsection" href="#field_splitter">
<link title="Making true executables" rel="Subsection" href="#true_exec">
<link title="Making bytecode-only executables" rel="Subsection" href="#byte_exec">
<link title="Cash scripts" rel="Subsection" href="#2_Cashscripts">
<link title="Cash switches" rel="Subsection" href="#2_Cashswitches">
<title>Cash</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="index.html">Up</a>
&nbsp;</div>
<center><h1>Module <a href="type_Cash.html">Cash</a></h1></center>
<br>
<pre><span class="keyword">module</span> Cash: <code class="type">sig  end</code></pre><div class="info">
The Caml Shell<br>
</div>
<hr width="100%">
<br>
Cash is a Unix shell that is embedded within Objective Caml.  It's a Caml
implementation of (an as large as possible subset of) the API of Scsh, the
Scheme Shell by Olin Shivers.  See the
<a href="ftp://ftp.scsh.net/pub/scsh/0.5/scsh-manual.ps.gz">Scsh manual </a> of which this
manual is a mere adaptation.  (<i>This is to check that Olin "did it.  [He]
did it all by [him]self" --- you should at least read his foreword,
`Acknowledgments'.  In no way prior knowledge of Scsh is necessary to use
Cash.</i>)<br><br>
<br>
Cash is designed for writing useful standalone Unix programs and shell
scripts --- it spans a wide range of application, from ``script'' applications
usually handled with perl or sh, to more standard systems applications usually
written in C.
<p>

Cash has two components: a process notation for running programs and setting up
pipelines and redirections (not yet implemented), and a complete syscall library
for low-level access to the operating system.  This manual gives a complete
description of Cash.  (A general discussion of the design principles behind Scsh
can be found in the paper
<a href="ftp://ftp.scsh.net/pub/scsh/papers/scsh-paper.ps.gz">``A Scheme Shell'' </a>.<br><br>
<br>
<br>
<a name="2_Copyrightsourcecodelicense"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Copyright &amp; source-code license</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Cash open-source and can be freely redistributed; it is distributed under
the terms of the GNU Lesser General Public License version 2.1 (see the file
<code class="code">LGPL</code> in the distribution).<br><br>
<br>
<br>
<a name="2_Caveats"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Caveats</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
It is important to note what Cash is <i>not</i>, as well as what it is.  Cash
is primarily designed for the writing of shell scripts --- programming.  It is
not a very comfortable system for interactive command use: the current release
lacks job control, command-line editing, a terse, convenient command syntax, and
it does not read in an initialisation file analogous to <code class="code">login</code> or <code class="code">.profile</code>.
<p>

However, Cash has a version string:<br><br>
<pre><span class="keyword">val</span> <a name="VALversion"></a>version : <code class="type">string</code></pre><br>
<br>
<a name="2_Namingconventions"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Naming conventions</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Following Scsh, we use a general naming scheme that consistently employs a
set of abbreviations.  This is intended to make it easier to remember the names
of things.<br><br>
<br>
<br>
<a name="3_Commonnamingconventions"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Common naming conventions</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Some of the common conventions we share with Scsh are:<ul>
<li><code class="code">fdes</code> or <code class="code">fd</code> means ``file descriptor,'' a small integer used in Unix to
  represent I/O channels.</li>
<li><code class="code">call_with_...</code> Procedures that call their argument on some computed value are
  usually named <code class="code">call_with_...</code>, <i>e.g.</i>, <code class="code">call_with_fdes_in</code> <i>in_channel</i>
  <i>proc</i>, which calls <i>proc</i> on <i>in_channel</i>'s file descriptor, returning
  whatever <i>proc</i> returns.  The abbreviated name means ``call with file
  descriptor from in_channel.''</li>
<li><code class="code">with_...</code> Procedures that call their argument in some special dynamic context
  frequently have names of the form <code class="code">with_...</code>.  For example, <code class="code">with_env</code> <i>env</i>
  <i>thunk</i>. These functions set the process environment body, execute their
  thunk, and then return after resetting the environment to its original state.</li>
<li><code class="code">create_...</code> or <code class="code">delete_...</code> Procedures that create (resp. delete) objects in
  the file system (files, directories, temp files, fifos, <i>etc.</i>), begin with
  <code class="code">create_...</code> (resp. <code class="code">delete_...</code>).</li>
<li><code class="code">low_...</code> These are lower-level Cash primitives that are not commonly used
  (but for implementing the higher-level ones).</li>
<li><code class="code">..._info...</code> Data structures packaging up information about various OS
  entities frequently end in ...<code class="code">_info</code>. Examples:
        <code class="code">user_info_...</code>, <code class="code">file_info_...</code>, <code class="code">group_info_...</code>, and <code class="code">host_info_...</code>.</li>
</ul>
<br><br>
<br>
<br>
<a name="3_Cashownnamingconventions"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Cash own naming conventions</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
This paragraph is intended for users already familiar with Scsh, to help
 them to find the corresponding procedures' names while translating their
 scripts :-).  You may skip it it you wish.<br><br>
<br>
We had to extend Scsh's conventions for two sorts of reasons: first, Caml
being statically typed, Scsh's polymorphic procedures are often present in 2 to
4 versions in Cash, suffixed by a type tag indicative of the type of the main
argument this procedure operates on.  The most common tags are:<ul>
<li>..._in : argument is an in_channel</li>
<li>..._out: argument is an out_channel</li>
<li>..._fd : argument is a file descriptor</li>
<li>..._fn : argument is a file name</li>
</ul>
<br><br>
<br>
Second, Caml is much stricter about the lexical syntax of its identifiers
than Lisp like languages, so we generally translated them this way:<ul>
<li><code class="code">from-&gt;to</code> becomes <code class="code">to_of_from</code>, staying in Caml's naming philosophy</li>
<li><code class="code">predicate?</code> becomes <code class="code">is_predicate</code>.  Combined with the first extension, this
  gives, <i>e.g.</i>, <code class="code">file-directory?</code> comes in the 4 flavors
  <code class="code">is_file_directory_fn</code>, <code class="code">is_file_directory_fd</code>, <code class="code">is_file_directory_in</code> and
  <code class="code">is_file_directory_out</code>.</li>
<li><code class="code">!</code>, the Scheme marker for side-effecting procedures, becomes <code class="code">_bang</code> (for
  lack of a better translation).</li>
</ul>

There are several exceptions: <code class="code">file-exists?</code> becomes the slightly more euphonic
<code class="code">is_file_existing_fn</code>, <code class="code">is_file_existing_fd</code>, <i>etc.</i> and <code class="code">file-not-exist?</code> is
<code class="code">file_not_exists_fn</code>, <code class="code">file_not_exists_fd</code>, <i>etc.</i> because it doesn't yield a
bool in Cash and is no more really a predicate. <code class="code">move-&gt;fdes</code> has the 3 versions
<code class="code">move_fd_to_fdes</code>, <code class="code">move_in_channel_to_fdes</code> and <code class="code">move_out_channel_to_fdes</code>.
There are more around <code class="code">dup</code>-ing procedures (see section <a href="Cash.html#unixio"><i>Unix I/O</i></a>).
<p>

All this generally makes identifiers even longer than the Scheme ones (sorry for
this), except for <code class="code">(current-input-port)</code> or <code class="code">(with-current-input-port ...)</code>
which become the more civilized <code class="code">stdin</code> and <code class="code">with_stdin ...</code>.<br><br>
<br>
<br>
<a name="2_AwordaboutUnixstandards"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">A word about Unix standards</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
"The wonderful thing about Unix standards is that there are so many to
choose from."  You may be totally bewildered about the multitude of various
standards that exist.  Rest assured that this nowhere in this manual will you
encounter an attempt to spell it all out for you; you could not read and
internalise such a twisted account without bleeding from the nose and ears.
<p>

However, you might keep in mind the following simple fact: of all the standards,
Posix is the least common denominator.  So when this manual repeatedly refers to
Posix, the point is ``the thing we are describing should be portable just about
anywhere.''  Cash sticks to Posix when at all possible; its major departure is
symbolic links, which aren't in Posix (see --- it really <em>is</em> a least common
denominator).<br><br>
<br>
<br>
<a name="1_Processnotation"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title1"><td><div align=center>
<span class="title1">Process notation</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Scsh has a notation for controlling Unix processes that takes the form of
s-expressions; this notation can then be embedded inside of standard Scheme
code.  This notation is not yet done for Cash.  If you want to have a feeling of
what it'll resemble to, refer to the
<a href="ftp://ftp.scsh.net/pub/scsh/0.5/scsh-manual.ps.gz">Scsh manual </a>, chapter
2.  Thus we skip directly to the basic blocks on top of which this notation is
built (after a little advertising for the Scsh API).<br><br>
<br>
<br>
<a name="2_Proceduresandsyntaxextensions"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Procedures and syntax extensions</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
It is a general design principle in Scsh/Cash that all functionality made
available through special syntax is also available in a straightforward
procedural form.  So there are procedural equivalents for all of the process
notation.  In this way, the programmer is not restricted by the particular
details of the syntax.<br><br>
<br>
Having a solid procedural foundation also allows for general notational
experimentation using Camlp4 macros.  For example, the programmer can build his
own pipeline notation on top of the <code class="code">fork</code> and <code class="code">fork_with_pipe</code> procedures.
Chapter <a href="Cash.html#syscalls"><i>System calls</i></a> gives the full story on all the procedures in the
syscall library.<br><br>
<br>
<br>
<a name="2_InterfacingprocessoutputtoCaml"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Interfacing process output to Caml</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
There is a family of procedures that can be used to capture the output of
processes as Caml data.<br><br>
<br>
<code class="code">run_with_...</code> all fork off subprocesses, collecting the process' output to
stdout in some form or another.  The subprocess runs with file descriptor 1 and
the current <code class="code">stdout</code> channel bound to a pipe.<br><br>
<pre><span class="keyword">val</span> <a name="VALrun_with_in_channel"></a>run_with_in_channel : <code class="type">(unit -> unit) -> Pervasives.in_channel</code></pre><div class="info">
Value is an in_channel open on process's <code class="code">stdout</code>.
  Returns immediately after forking child.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrun_with_out_channel"></a>run_with_out_channel : <code class="type">(unit -> unit) -> Pervasives.out_channel</code></pre><div class="info">
Value is an out_channel open on process's <code class="code">stdin</code>.
  Returns immediately after forking child.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrun_with_file"></a>run_with_file : <code class="type">(unit -> unit) -> string</code></pre><div class="info">
Value is name of a temp file containing process's output.
  Returns when process exits.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrun_with_string"></a>run_with_string : <code class="type">(unit -> unit) -> string</code></pre><div class="info">
Value is a string containing process' output.
  Returns when eof read.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrun_with_strings"></a>run_with_strings : <code class="type">(unit -> unit) -> string list</code></pre><div class="info">
Splits process' output into a list of newline-delimited strings.  Returns
when eof read.  The delimiting newlines are not included in the strings
returned.<br>
</div>
<br>
In sexp procedures below, `data', `object' and `item' should conform to some
Lisp/Scheme syntax.  See sexp.mli and atomo.mll for details on the supported
syntax.  <code class="code">Sexp.simple</code> values can be printed with <code class="code">Sexp.display</code>.<br><br>
<pre><span class="keyword">val</span> <a name="VALrun_with_sexp"></a>run_with_sexp : <code class="type">(unit -> unit) -> Sexp.simple</code></pre><div class="info">
Reads a single object from process' stdout with <code class="code">Sexp.read</code>.
  Returns as soon as the read completes .<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrun_with_sexps"></a>run_with_sexps : <code class="type">(unit -> unit) -> Sexp.simple list</code></pre><div class="info">
Repeatedly reads objects from process' stdout with <code class="code">Sexp.read</code>.
  Returns accumulated list upon eof.<br>
</div>
<br>
The following procedures are also of utility for generally parsing
    input streams in Cash.<br><br>
<pre><span class="keyword">val</span> <a name="VALstring_of_in_channel"></a>string_of_in_channel : <code class="type">Pervasives.in_channel -> string</code></pre><div class="info">
Reads the channel until eof, then returns the accumulated string.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsexp_list_of_in_channel"></a>sexp_list_of_in_channel : <code class="type">Pervasives.in_channel -> Sexp.simple list</code></pre><div class="info">
Repeatedly reads data from the channel until eof, then returns the accumulated
  list of items in a schemeish form.  Note: you can read one item with
  <code class="code">Sexp.read</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstring_list_of_in_channel"></a>string_list_of_in_channel : <code class="type">Pervasives.in_channel -> string list</code></pre><div class="info">
Repeatedly reads newline-terminated strings from the channel until eof, then
  returns the accumulated list of strings. The delimiting newlines are not part
  of the returned strings.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlist_of_in_channel"></a>list_of_in_channel : <code class="type">(Pervasives.in_channel -> 'a) -> Pervasives.in_channel -> 'a list</code></pre><div class="info">
Generalises these two procedures.
  It uses a reader to repeatedly read objects from a channel.
  It accumulates these objects into a list, which is returned upon eof.<br>
</div>
<br>
The <code class="code">string_list_of_in_channel</code> and <code class="code">sexp_list_of_in_channel</code> procedures
  are trivial to define, being merely <code class="code">list_of_in_channel</code> curried with the
  appropriate parsers:
<pre><code class="code"> let string_list_of_in_channel = list_of_in_channel input_line
 let sexp_list_of_in_channel = list_of_in_channel Sexp.read </code></pre><br><br>
<br>
The following compositions also hold:
<pre><code class="code"> run_with_string thunk = run_with_in_channel o string_of_in_channel
 run_with_strings thunk = run_with_in_channel o string_list_of_in_channel
 run_with_sexp thunk = run_with_in_channel o Sexp.read
 run_with_sexps thunk = run_with_in_channel o sexp_list_of_in_channel </code></pre><br><br>
<pre><span class="keyword">val</span> <a name="VALfold_in_channel"></a>fold_in_channel : <code class="type">Pervasives.in_channel -><br>       (Pervasives.in_channel -> 'a) -> ('a -> 'b -> 'b) -> 'b -> 'b</code></pre><div class="info">
<code class="code">fold_in_channel</code> <i>ichan reader op seed</i> can be used to perform a variety of
iterative operations over an input stream.  It repeatedly uses <i>reader</i> to
read an object from <i>ichan</i>.  If the first read returns eof, then the entire
<code class="code">fold_in_channel</code> operation returns the seed.  If the first read operation
returns some other value <i>v</i>, then <i>op</i> is applied to <i>v</i> and the seed:
 <i>op v seed</i>.
This should return a new seed value, and the reduction then loops, reading a new
value from the channel, and so forth.
<p>

For example, <code class="code">list_of_in_channel</code> <i>reader channel</i> could be (and in fact is)
defined as
<pre><code class="code">        List.rev (fold_in_channel channel reader (::) [])
</code></pre> 
An imperative way to look at <code class="code">fold_in_channel</code> is to say that it abstracts the
idea of a loop over a stream of values read from some channel, where the seed
value expresses the loop state.<br>
</div>
<br>
<br>
<a name="2_Morecomplexprocessoperations"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">More complex process operations</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The procedures in the previous section provide for the common case, where
the programmer is only interested in the output of the process.  These
procedures provide more complicated facilities for manipulating processes.<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEproc"></a>proc = <code class="type">Proc_3_4.proc</code> </code>
<div class="info">
The type of a process object; it encapsulates the subprocess' process id and
exit code; it is the value passed to the <a href="Cash.html#VALwait"><code class="code">wait</code></a> system call (which gives access
to the exit code when it is ready).  See also <a href="Cash.html#VALpid_of_proc"><code class="code">pid_of_proc</code></a><br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALrun_with_inchan_plus_proc"></a>run_with_inchan_plus_proc : <code class="type">(unit -> unit) -> Pervasives.in_channel * <a href="Cash.html#TYPEproc">proc</a></code></pre><div class="info">
This procedure can be used if the programmer also wishes access to the
process' pid, exit status, or other information.  It forks off a subprocess,
returning two values: a channel open on the process' stdout (and current
<code class="code">stdout</code>), and the subprocess's process object.
<p>
For example, to uncompress a tech report, reading the uncompressed data into
Cash, and also be able to track the exit status of the decompression process,
use the following:
<pre><code class="code">  let (chan, child) =
    run_with_inchan_plus_proc (fun () -&gt; exec_path "zcat" ["tr91-145.tex.Z"]}) in
  let paper = string_of_in_channel chan in
  let status = wait child in
  (* ...use paper, status and child here... *) </code></pre><br>
</div>
<br>
Note that you must <i>first</i> do the <code class="code">string_of_in_channel</code> and <i>then</i>
do the <code class="code">wait</code> --- the other way around may lock up when the zcat fills up its
output pipe buffer.<br><br>
<pre><span class="keyword">val</span> <a name="VALrun_with_outchan_plus_proc"></a>run_with_outchan_plus_proc : <code class="type">(unit -> unit) -> Pervasives.out_channel * <a href="Cash.html#TYPEproc">proc</a></code></pre><div class="info">
This procedure is the dual of the preceding: the program has to write to the
child's stdin.  It forks off a subprocess, returning two values: a channel open
on the process' stdin (and current <code class="code">stdin</code>), and the subprocess's process
object.  (Be prepared to SIGPIPE).<br>
</div>
<br>
<br>
<a name="2_Multiplestreamcapture"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Multiple stream capture</span>
</div>
</td>
</tr>
</table>
<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEfd"></a>fd = <code class="type">int</code> </code>
<div class="info">
The Unix view of file descriptors.  See <a href="Cash.html#gen_io"><i>I/O</i></a> for explanations
about how file descriptors are managed by Cash.<br>
</div>
<br>
<br>
Occasionally, the programmer may want to capture multiple distinct output
streams from a process. For instance, he may wish to read the stdout and stderr
streams into two distinct strings. This is accomplished with the
<code class="code">run_with_collecting</code> procedure.<br><br>
<pre><span class="keyword">val</span> <a name="VALrun_with_collecting"></a>run_with_collecting : <code class="type"><a href="Cash.html#TYPEfd">fd</a> list -><br>       (unit -> unit) -> Unix.process_status * Pervasives.in_channel list</code></pre><div class="info">
Run processes that produce multiple output streams and return channels open
on these streams.  To avoid issues of deadlock, <code class="code">run_with_collecting</code> doesn't use
pipes. Instead, it first runs the process with output to temp files, then
returns channels open on the temp files. For example,
<pre><code class="code">  run_with_collecting [1; 2] (fun () -&gt; exec_path "ls" []) </code></pre>
runs <code class="code">ls</code> with stdout (fd 1) and stderr (fd 2) redirected to temporary
files.
When the <code class="code">ls</code> is done, <code class="code">run_with_collecting</code> returns three values: the
<code class="code">ls</code> process' exit status, and two channels open on the temporary files. The
files are deleted before <code class="code">run_with_collecting</code> returns, so when the channels are
closed, they vanish.
<p>
For example, if Kaiming has his mailbox protected, then
<pre><code class="code">  let (status, fds) =
     run_with_collecting [1; 2]
       (fun () -&gt; exec_path "cat" ["/usr/kmshea/mbox"]) in
   (status, List.map string_of_in_channel fds) </code></pre>
might produce
<pre>- : (Unix.process_status * list string) =
(Unix.WEXITED 1, [""; "cat: /usr/kmshea/mbox: Permission denied\n"])</pre><br>
</div>
<br>
<br>
<a name="2_Processfilters"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Process filters</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
These procedures are useful for forking off processes to filter text streams.<br><br>
<pre><span class="keyword">val</span> <a name="VALchar_filter"></a>char_filter : <code class="type">(char -> char) -> unit -> unit</code></pre><div class="info">
Returns a procedure that when called, repeatedly reads a character from the
    current <code class="code">stdin</code>, applies its first argument <i>filter</i> to the character, and
    writes the result to the current <code class="code">stdout</code>.  The procedure returns upon
    reaching eof on <code class="code">stdin</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstring_filter"></a>string_filter : <code class="type">?buflen:int -> (string -> string) -> unit -> unit</code></pre><div class="info">
Returns a procedure that when called, repeatedly reads a string from the
    current <code class="code">stdin</code>, applies its first argument <i>filter</i> to the string, and
    writes the result to the current <code class="code">stdout</code>.  The procedure returns upon
    reaching eof on <code class="code">stdin</code>.
<p>

    The optional <code class="code">buflen</code> argument controls the number of characters each
    internal read operation requests; this means that <code class="code">filter</code> will never be
    applied to a string longer than <code class="code">buflen</code> chars.  The default <code class="code">buflen</code> value
    is 1024.<br>
</div>
<br>
<br>
<a name="syscalls"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title1"><td><div align=center>
<span class="title1">System calls</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Cash aims at providing essentially complete access to the basic Unix kernel
services: processes, files, signals and so forth.  As the <code class="code">Unix</code> module provides
a fairly good Posix interface, Cash often relies on it to give an extended
interface.  In particular, it uncovers the opaque <code class="code">Unix.file_descr</code> type, and
all the necessary connections with the so-called `revealed' channels.  Cash adds
very few restrictions to the way <code class="code">Pervasives</code>, <code class="code">Unix</code> and <code class="code">Cash</code> functions
(especially I/O) may be freely intermixed. <i>E.g.</i>, <code class="code">Unix.read</code> on a
<code class="code">Unix.file_descr</code> obtained by <code class="code">Unix.in_channel_of_descr</code> still needs careful
synchonization with <code class="code">Unix.lseek</code> and/or <code class="code">seek_in/tell_in</code> if Pervasives I/O is
to be interleaved.<br><br>
<br>
<br>
<a name="2_Errors"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Errors</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The <code class="code">Unix</code> module already raises exceptions for any errno &lt;&gt; 0, so if any
syscall returns, it succeeded.  Note that Cash should automatically retry any
interrupted system call it defines, so they never raise <code class="code">Unix.EINTR</code>.<br><br>
<pre><span class="keyword">val</span> <a name="VALerrno_error"></a>errno_error : <code class="type">Unix.error -> string -> string -> 'a</code></pre><div class="info">
Raises a <code class="code">Unix</code> error exception for <code class="code">Unix.error</code> argument.
  This is just for compatibility with Scsh.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALunwind_protect"></a>unwind_protect : <code class="type">(unit -> 'a) -> ('b -> unit) -> 'b -> 'a</code></pre><div class="info">
<code class="code">unwind_protect</code> <i>thunk protect ed</i>, named after a similar functionality
of Lisp, calls thunk, then, before returning its result (be it a value or an
exception), ensures that <i>protect</i> is applied to <i>ed</i>.  It can be used,
<i>e.g.</i>, to ensure that a file is closed after an action, regardless of any
exception this action may raise.<br>
</div>
<br>
<br>
<a name="gen_io"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">I/O</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
<br>
<a name="3_PervasivesIOoperations"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Pervasives I/O operations</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Contrarily to Scsh, when using file descriptors, Cash doesn't attempt to
bypass the underlying I/O system, which is reasonably efficient.  So to use
<code class="code">Pervasives</code> primitives on file descriptors, you should use <code class="code">in_channel_of_fd</code> or
<code class="code">out_channel_of_fd</code> to get the proper channel.  <code class="code">Unix read</code> and <code class="code">write</code> primitives are
still available for those who <i>really</i> want them.<br><br>
<br>
<br>
<a name="withstd"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Channel manipulation and standard channels</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALclose_fd_after"></a>close_fd_after : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> (<a href="Cash.html#TYPEfd">fd</a> -> 'a) -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALclose_in_after"></a>close_in_after : <code class="type">Pervasives.in_channel -> (Pervasives.in_channel -> 'a) -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALclose_out_after"></a>close_out_after : <code class="type">Pervasives.out_channel -> (Pervasives.out_channel -> 'a) -> 'a</code></pre><div class="info">
<code class="code">close_..._after</code> <i>channel/fd consumer</i> return <i>(consumer channel/fd)</i>,
but close the channel (or file descriptor) on return.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwith_stdin"></a>with_stdin : <code class="type">Pervasives.in_channel -> (unit -> 'a) -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALwith_stdout"></a>with_stdout : <code class="type">Pervasives.out_channel -> (unit -> 'a) -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALwith_stderr"></a>with_stderr : <code class="type">Pervasives.out_channel -> (unit -> 'a) -> 'a</code></pre><div class="info">
These procedures install the given channel as the <code class="code">stdin</code>, <code class="code">stdout</code>, and
<code class="code">stderr</code> channel, respectively, for the duration of a call to their 2d argument.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_stdin"></a>set_stdin : <code class="type">Pervasives.in_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_stdout"></a>set_stdout : <code class="type">Pervasives.out_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_stderr"></a>set_stderr : <code class="type">Pervasives.out_channel -> unit</code></pre><div class="info">
These procedures set the standard I/O channels to new values, the old ones being
abandoned in the great bit bucket --- no flush, no close.<br>
</div>
<br>
NOTE: The six procedures above don't change the file descriptor associated
to their channel argument, so <i>e.g.</i>, <code class="code">stdout</code> may be associated to another
file descriptor than 1.  Use <code class="code">(out_channel_of_fd 1)</code> to get a non-side-effected
channel.  So you can go fishin' in the great bit bucket...  <code class="code">flush_all</code> will
flush those channels too.<br><br>
<pre><span class="keyword">val</span> <a name="VALclose_in"></a>close_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALclose_out"></a>close_out : <code class="type">Pervasives.out_channel -> bool</code></pre><div class="info">
Closing a channel or file descriptor: the 3 procedures around return true if they
closed an open channel/fd (this differs from <code class="code">Pervasives.close_{in,out}</code>).  If
the channel was already closed, they return false; this is not an error.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALclose_fd"></a>close_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><div class="info">
If the <code class="code">fd</code> arg to close_fd has a channel allocated to it, the channel is
shifted to a new file descriptor created with <code class="code">{in,out}_channel_of_dup_fd fd</code>
before closing the <code class="code">fd</code>. The channel then has its revealed count set to zero.
This reflects the design criteria that channels are not associated with file
descriptors, but with open files.
<p>

To close a file descriptor, and any associated channel it might have, you
must instead say one of (as appropriate):
<pre><code class="code">  close_in (in_channel_of_fd fd)
  close_out (out_channel_of_fd fd)</code></pre><br>
</div>
<br>
These two procedures are used to synchronise Unix' standard I/O
  file descriptors and Caml's current I/O channels.<br><br>
<pre><span class="keyword">val</span> <a name="VALstdchans_to_stdio"></a>stdchans_to_stdio : <code class="type">unit -> unit</code></pre><div class="info">
This causes the standard I/O file descriptors (0, 1, and 2) to
take their values from the current standard I/O channels.  It is exactly
equivalent to the series of redirections:
<pre><code class="code">   fdes_of_dup_in ~newfd:0 stdin;
   fdes_of_dup_out ~newfd:1 stdout;
   fdes_of_dup_out ~newfd:2 stderr </code></pre>
Why not <code class="code">move_..._to_fdes</code>? Because <code class="code">stdout</code> and <code class="code">stderr</code> might be the same channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstdio_to_stdchans"></a>stdio_to_stdchans : <code class="type">unit -> unit</code></pre><div class="info">
This causes the bindings of the current standard I/O channels
to be changed to channels constructed over the standard I/O file descriptors.
It is exactly equivalent to the series of assignments:
<pre><code class="code">   set_stdin (in_channel_of_fd 0);
   set_stdout (out_channel_of_fd 1);
   set_stderr (out_channel_of_fd 2)</code></pre>
<p>

However, you are more likely to find the dynamic-extent variant,
<code class="code">with_stdio_channels</code>, below, to be of use in general programming.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwith_stdio_chans"></a>with_stdio_chans : <code class="type">(unit -> 'a) -> 'a</code></pre><div class="info">
Binds the standard channels <code class="code">stdin</code>, <code class="code">stdout</code>, and <code class="code">stderr</code> to be channels
  on file descriptors 0, 1, 2, and then calls its 1st argument.
  <code class="code">with_stdio_chans thunk</code> is equivalent to:
<pre><code class="code">  with_stdin (in_channel_of_fd 0)
    (fun () -&gt; with_stdout (out_channel_of_fd 1)
       (fun () -&gt; with_stderr (out_channel_of_fd 2) thunk))</code></pre><br>
</div>
<br>
<br>
<a name="3_Stringchannels"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">String channels</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Ocaml has no string channels, but Cash emulates them with temp files.<br><br>
<pre><span class="keyword">val</span> <a name="VALmake_string_in_channel"></a>make_string_in_channel : <code class="type">string -> Pervasives.in_channel</code></pre><div class="info">
Returns a channel that reads characters from the supplied string.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmake_string_out_channel"></a>make_string_out_channel : <code class="type">unit -> Pervasives.out_channel</code></pre><div class="info">
A string output channel is a channel that collects the characters given to
it into a string (well, a temp file, in fact).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstring_out_channel_output"></a>string_out_channel_output : <code class="type">?close:bool -> Pervasives.out_channel -> string</code></pre><div class="info">
The accumulated string is retrieved by applying <code class="code">string_out_channel_output</code>
 to the channel.  You can call this even on a closed channel.  However, as the
emulation maintains a hidden input channel on the temp file, you can use a <i>~close:true</i> argument to close both channels, and free the underlying disk
storage. This will also make the out_channel unrecognised as a string output
channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcall_with_string_out_channel"></a>call_with_string_out_channel : <code class="type">?close:bool -> (Pervasives.out_channel -> unit) -> string</code></pre><div class="info">
The first arg <i>procedure</i> value is called on a channel.  When it returns,
 <code class="code">call_with_string_out_channel</code> returns a string containing the characters that
 were written to that channel during the execution of <i>procedure</i>.<br>
</div>
<br>
<br>
<a name="3_Revealedchannelsandfiledescriptors"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Revealed channels and file descriptors</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The material in this section and the following one is not critical for most
applications.  You may safely skim or completely skip this section on a first
reading.
<p>

Caml doesn't specify what happens to the file descriptor when a channel is
garbage-collected: is it closed or not ?  In the following discussion, we
suppose the same behaviour as many Scheme implementations which close channels
when they collect them.  Anyway, the same arguments apply when exec'ing another
program.
<p>

Dealing with Unix file descriptors in a Caml environment is difficult.  In Unix,
open files are part of the process environment, and are referenced by small
integers called <em>file descriptors</em>. Open file descriptors are the fundamental
way I/O redirections are passed to subprocesses, since file descriptors are
preserved across fork's and exec's.
<p>

Caml, on the other hand, uses channels for specifying I/O sources. Channels are
garbage-collected Caml objects, not integers.  When a channel becomes
unreachable, it can be collected (and the associated file descriptor may be
closed).  Because file descriptors are just integers, it's impossible to garbage
collect them --- one wouldn't be able to collect an unreachable channel on file
descriptor 3 unless there were no 3's in the system, and you could further prove
that your program would never again compute a 3. This is difficult at best.
<p>

If a Caml program only used Caml channels, and never actually used file
descriptors, this would not be a problem. But Caml code must descend to the file
descriptor level in at least two circumstances:<ul>
<li>when interfacing to foreign code</li>
<li>when interfacing to a subprocess.</li>
</ul>

This causes a problem. Suppose we have a Caml channel constructed on top of file
descriptor 2. We intend to fork off a program that will inherit this file
descriptor. If we drop references to the channel, the garbage collector could
prematurely close file 2 before we fork the subprocess. The interface described
below is intended to fix this and other problems arising from the mismatch
between channels and file descriptors.
<p>

The Caml runtime maintains a list of open channels, from which one can retrieve
the Caml channel allocated for a given file descriptor. Cash imposes the further
restriction that there is at most one open channel for each open file
descriptor.  This is not enforced by the <code class="code">Unix</code> module's functions
<code class="code">{in,out}_channel_of_descr</code>, which will happily allocate a new channel each time
they are called, each with its own buffer, but the system only knows one
position in the file --- the Caml runtime behaviour can be understood, but only
with serious insight (and the sources).  So, for <code class="code">Cash.{in,out}_channel_of_fd</code>
to be able to give an unambiguous answer (i.e. the previously opened channel on
this fd, not anyone of those already opened, nor a new one --- except if there
was none ---), you should only use the Cash versions.  In any case, if there are
more than one channel opened on a file descriptor, these functions will signal
an error.  This is nearly the only incompatibility between <code class="code">Unix</code> and <code class="code">Cash</code>
(the second being that <code class="code">Unix.open_file</code> doesn't call <code class="code">set_close_on_exec</code>).<br><br>
<br>
The channel data structure has one Cash-specific field besides the
descriptor: <i>revealed</i>.  When a channel is closed with <code class="code">(close_{in,out}
channel)</code>, the channel's file descriptor is closed, it is unlinked from the open
channel list, and the channel's <i>descriptor</i> field is reset to some "no fd"
value.
<p>

When a file descriptor is closed with <code class="code">(close_fd fdes)</code>, any associated channel
is shifted to a new file descriptor created with <code class="code">({in,out}_channel_of_dup_fd
fdes)</code>.  The channel has its revealed count reset to zero (and hence becomes
eligible for closing on exec or GC). See discussion below.  To really put a
stake through a descriptor's heart without waiting for associated channels to be
closed, you must say one of <pre><code class="code">
   close_in (in_channel_of_fd fdes)
   close_out (out_channel_of_fd fdes)
</code></pre>
<p>

The <i>revealed</i> field is an aid to garbage collection. It is an integer
semaphore. If it is zero, the channel's file descriptor can be closed when the
channel is collected. Essentially, the <i>revealed</i> field reflects whether or
not the channel's file descriptor has escaped to the Caml user. If the Caml user
doesn't know what file descriptor is associated with a given channel, then he
can't possibly retain an ``integer handle'' on the channel after dropping
pointers to the channel itself, so the garbage collector is free to close the
file.
<p>

Channels allocated with <code class="code">open_in</code> and <code class="code">open_out</code> are unrevealed channels --- <i>i.e.</i>, <i>revealed</i> is initialised to 0.  No one knows the channel's file
descriptor, so the file descriptor can be closed when the channel is collected.
<p>

The functions <code class="code">{in,out}_channel_of_fd</code> and <code class="code">fd_of_{in,out}_channel</code> are used to
shift back and forth between file descriptors and channels.  When
<code class="code">fd_of_{in,out}_channel</code> reveals a channel's file descriptor, it increments the
channel's <i>revealed</i> field.  When the user is through with the file
descriptor, he can call <code class="code">release_{in,out}_channel_handle</code> <i>channel</i>, which
decrements the count.  The functions <code class="code">call_with_fdes_{in,out}</code> <i>channel proc</i>
automate this protocol.  If <i>proc</i> throws out of the <code class="code">call_with_fdes_...</code>
application, the exception is caught, the descriptor handle released, then the
exception is re-raised.  When the user maps a file descriptor to a channel with
<code class="code">{in,out}_channel_of_fd</code>, the channel has its revealed field incremented.
<p>

Not all file descriptors are created by requests to make channels.  Some are
inherited on process invocation via <code class="code">exec(2)</code>, and are simply part of the global
environment. Subprocesses may depend upon them, so if a channel is later
allocated for these file descriptors, is should be considered as a revealed
channel. For example, when the Caml shell's process starts up, it opens channels
on file descriptors 0, 1, and 2 for the initial values of <code class="code">stdin</code>, <code class="code">stdout</code>, and
<code class="code">stderr</code>.  These channels are initialised with <i>revealed</i> set to 1, so that
<code class="code">stdin</code>, <code class="code">stdout</code>, and <code class="code">stderr</code> are not closed even if the user drops the
channel.<br><br>
<br>
Unrevealed file channels have the nice property that they can be closed when all
pointers to the channel are dropped. This can happen during gc, or at an
<code class="code">exec()</code> --- since all memory is dropped at an <code class="code">exec()</code>.  No one knows the
file descriptor associated with the channel, so the exec'd process certainly
can't refer to it.
<p>

This facility preserves the transparent may-close-on-collect property for file
channels that are used in straightforward ways, yet allows access to the
underlying Unix substrate without interference from the garbage collector. This
is critical, since shell programming absolutely requires access to the Unix file
descriptors, as their numerical values are a critical part of the process
interface.
<p>

A channel's underlying file descriptor can be shifted around with <code class="code">dup(2)</code> when
convenient. That is, the actual file descriptor on top of which a channel is
constructed can be shifted around underneath the channel by the Cash runtime
when necessary.  This is important, because when the user is setting up file
descriptors prior to a <code class="code">exec(2)</code>, he may explicitly use a file descriptor that
has already been allocated to some channel. In this case, the Cash runtime just
shifts the channel's file descriptor to some new location with <code class="code">dup</code>, freeing up
its old descriptor.  This prevents errors from happening in the following
scenario.  Suppose we have a file open on channel <i>f</i>.  Now we want to run a
program that reads input on file 0, writes output to file 1, errors to file 2,
and logs execution information on file 3. We want to run this program with input
from <i>f</i>.  So we write (in an sh-like syntax,  since Cash pipeline syntax is
not fixed for now --- here, <i>$f$</i> denotes a Caml input channel):<br><br>
<br>
<code class="code"> &lt;&lt;run "/usr/shivers/bin/prog 1&gt;output.txt 2&gt;error.log 3&gt;trace.log 0&lt;</code><i>$f$</i><code class="code">"&gt;&gt;</code>
<p>

Now, suppose by ill chance that, unbeknownst to us, when the operating system
opened <i>f</i>'s file, it allocated descriptor 3 for it. If we blindly redirect
<code class="code">trace.log</code> into file descriptor 3, we'll clobber <i>f</i> !  However, the
channel-shuffling machinery saves us: when the <code class="code">&lt;&lt;run ...&gt;&gt;</code> form tries to dup
<code class="code">trace.log</code>'s file descriptor to 3, <code class="code">dup</code> will notice that file descriptor 3 is
already associated with an unrevealed channel (<i>i.e.</i>, <i>f</i>). So, it will
first move <i>f</i> to some other file descriptor. This keeps <i>f</i> alive and well
so that it can subsequently be dup'd into descriptor 0 for <code class="code">prog</code>'s stdin.
<p>

The channel-shifting machinery makes the following guarantee: a channel is only
moved when the underlying file descriptor is closed, either by a <code class="code">close()</code> or a
<code class="code">dup2()</code> operation. Also when explicitly asked by <a href="Cash.html#VALwith_stdin"><code class="code">with_stdin</code></a>,
<code class="code">set_stdout</code> and consorts. Otherwise a channel/file-descriptor association is
stable.
<p>

Under normal circumstances, all this machinery just works behind the scenes to
keep things straightened out. The only time the user has to think about it is
when he starts accessing file descriptors from channels, which he should almost
never have to do. If a user starts asking what file descriptors have been
allocated to what channels, he has to take responsibility for managing this
information.<br><br>
<br>
<br>
<a name="3_Channelmappingmachinery"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Channel-mapping machinery</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The procedures provided in this section are almost never needed.
You may safely skim or completely skip this section on a first reading.
<p>

Here are the routines for manipulating channels in Cash. The important points to
remember are:<ul>
<li>A channel is associated with an open file, not a particular file descriptor.</li>
<li>The association between a channel and a particular file descriptor is never
  changed <i>except</i> when requested by <code class="code">set_std...</code> or <code class="code">with_std...</code>
  (see <a href="Cash.html#withstd"><i>Channel manipulation and standard channels</i></a>), or when the file descriptor is explicitly closed.
  ``Closing'' includes being used as the target of a <code class="code">dup2</code>, so the set of
  procedures below that close their targets are <code class="code">close_...</code>, two-argument
  <code class="code">dup_...</code>, and <code class="code">move_..._to_fdes</code>. If the target file descriptor of one of
  these routines has an allocated channel, the channel will be shifted to
  another freshly-allocated file descriptor, and marked as unrevealed, thus
  preserving the channel but freeing its old file descriptor.</li>
</ul>

These rules are what is necessary to ``make things work out'' with no surprises
in the general case.<br><br>
<pre><span class="keyword">val</span> <a name="VALin_channel_of_fd"></a>in_channel_of_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> Pervasives.in_channel</code></pre><pre><span class="keyword">val</span> <a name="VALout_channel_of_fd"></a>out_channel_of_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> Pervasives.out_channel</code></pre><pre><span class="keyword">val</span> <a name="VALfd_of_in_channel"></a>fd_of_in_channel : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEfd">fd</a></code></pre><pre><span class="keyword">val</span> <a name="VALfd_of_out_channel"></a>fd_of_out_channel : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEfd">fd</a></code></pre><div class="info">
These increment the channel's revealed count.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALin_channel_revealed"></a>in_channel_revealed : <code class="type">Pervasives.in_channel -> int</code></pre><pre><span class="keyword">val</span> <a name="VALout_channel_revealed"></a>out_channel_revealed : <code class="type">Pervasives.out_channel -> int</code></pre><div class="info">
Return the channel's revealed count.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrelease_in_channel_handle"></a>release_in_channel_handle : <code class="type">Pervasives.in_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALrelease_out_channel_handle"></a>release_out_channel_handle : <code class="type">Pervasives.out_channel -> unit</code></pre><div class="info">
Decrement the channel's revealed count.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcall_with_fdes_in"></a>call_with_fdes_in : <code class="type">(<a href="Cash.html#TYPEfd">fd</a> -> 'a) -> Pervasives.in_channel -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALcall_with_fdes_out"></a>call_with_fdes_out : <code class="type">(<a href="Cash.html#TYPEfd">fd</a> -> 'a) -> Pervasives.out_channel -> 'a</code></pre><div class="info">
<code class="code">call_with_fdes_...</code> <i>consumer channel</i> calls <i>consumer</i> on the file
 descriptor underlying <i>channel</i>; takes care of revealed bookkeeping.
While <i>consumer</i> is running, the <i>channel</i>'s revealed count is incremented.<br>
</div>
<br>
Mapping <code class="code">fd</code> -&gt; <code class="code">fd</code> and <code class="code">channel</code> -&gt; <code class="code">channel</code>.<br><br>
<pre><span class="keyword">val</span> <a name="VALmove_fd_to_fdes"></a>move_fd_to_fdes : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfd">fd</a></code></pre><br>
<code class="code">move_fd_to_fdes</code> <i>fd target-fd</i>: if <code class="code">fd</code> is a file-descriptor not equal
to <i>target-fd</i>, dup it to <i>target-fd</i> and close it. Returns <i>target-fd</i>.<br><br>
<pre><span class="keyword">val</span> <a name="VALmove_in_channel_to_fdes"></a>move_in_channel_to_fdes : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEfd">fd</a> -> Pervasives.in_channel</code></pre><pre><span class="keyword">val</span> <a name="VALmove_out_channel_to_fdes"></a>move_out_channel_to_fdes : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEfd">fd</a> -> Pervasives.out_channel</code></pre><div class="info">
<code class="code">move_{in,out}_channel_to_fdes</code> <i>channel target-fd</i>: <i>channel</i> is
shifted to <i>target-fd</i>, by duping its underlying file-descriptor if necessary.
<i>channel</i>'s original file descriptor is closed (if it was different from <i>target-fd</i>). Returns the channel.  This operation resets <i>channel</i>'s revealed
count to 1.<br>
</div>
<br>
In all cases when <i>fd</i> or <i>channel</i> is actually shifted, if there is a
channel already using <i>target-fd</i>, it is first relocated to some other file
descriptor.<br><br>
<br>
<br>
<a name="unixio"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Unix I/O</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The 9 next procedures provide the functionality of C's <code class="code">dup()</code> and
<code class="code">dup2()</code>.  The X_of_dup_Y ones convert any fd/channel to any other kind, and
X_of_dup_X is named dup_X.<br><br>
<pre><span class="keyword">val</span> <a name="VALdup_fd"></a>dup_fd : <code class="type">?newfd:<a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfd">fd</a></code></pre><pre><span class="keyword">val</span> <a name="VALfdes_of_dup_in"></a>fdes_of_dup_in : <code class="type">?newfd:<a href="Cash.html#TYPEfd">fd</a> -> Pervasives.in_channel -> <a href="Cash.html#TYPEfd">fd</a></code></pre><pre><span class="keyword">val</span> <a name="VALfdes_of_dup_out"></a>fdes_of_dup_out : <code class="type">?newfd:<a href="Cash.html#TYPEfd">fd</a> -> Pervasives.out_channel -> <a href="Cash.html#TYPEfd">fd</a></code></pre><pre><span class="keyword">val</span> <a name="VALin_channel_of_dup_fd"></a>in_channel_of_dup_fd : <code class="type">?newfd:<a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfd">fd</a> -> Pervasives.in_channel</code></pre><pre><span class="keyword">val</span> <a name="VALdup_in"></a>dup_in : <code class="type">?newfd:<a href="Cash.html#TYPEfd">fd</a> -> Pervasives.in_channel -> Pervasives.in_channel</code></pre><pre><span class="keyword">val</span> <a name="VALin_channel_of_dup_out"></a>in_channel_of_dup_out : <code class="type">?newfd:<a href="Cash.html#TYPEfd">fd</a> -> Pervasives.out_channel -> Pervasives.in_channel</code></pre><pre><span class="keyword">val</span> <a name="VALout_channel_of_dup_fd"></a>out_channel_of_dup_fd : <code class="type">?newfd:<a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfd">fd</a> -> Pervasives.out_channel</code></pre><pre><span class="keyword">val</span> <a name="VALout_channel_of_dup_in"></a>out_channel_of_dup_in : <code class="type">?newfd:<a href="Cash.html#TYPEfd">fd</a> -> Pervasives.in_channel -> Pervasives.out_channel</code></pre><pre><span class="keyword">val</span> <a name="VALdup_out"></a>dup_out : <code class="type">?newfd:<a href="Cash.html#TYPEfd">fd</a> -> Pervasives.out_channel -> Pervasives.out_channel</code></pre><div class="info">
These procedures use the Unix <code class="code">dup()</code> syscall to replicate their fd/channel
last argument.  If a <code class="code">newfd</code> file descriptor is given, it is used as the target
of the dup operation, i.e., the operation is a <code class="code">dup2()</code>.  In this case,
procedures that return a channel (such as <code class="code">dup_in</code>) will return one with the
revealed count set to one.  For example, <code class="code">dup_in ~newfd:5 stdin</code> produces a new
channel with underlying file descriptor 5, whose revealed count is 1.  If
<code class="code">newfd</code> is not specified, then the operating system chooses the file descriptor,
and any returned channel is marked as unrevealed.
<p>

If the <code class="code">newfd</code> target is given, and some channel is already using that file
descriptor, the channel is first quietly shifted (with another <code class="code">dup</code>) to some
other file descriptor (zeroing its revealed count).
<p>

Since Caml doesn't provide read/write channels, <code class="code">{in,out}_channel_of_dup_in</code> can
be useful for getting an output version of an input channel, or <i>vice versa</i>.
For example, if <code class="code">p</code> is an input channel open on a tty, and we would like to do
output to that tty, we can simply use <code class="code">out_channel_of_dup_in p</code> to produce an
equivalent output channel for the tty.  However, you are responsible for the
open modes of the channel when doing so.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEseek_command"></a>seek_command = <code class="type">Unix.seek_command</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SEEK_SET</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>positions are relative to the beginning of the file</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SEEK_CUR</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>positions are relative to the current position</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SEEK_END</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>positions are relative to the end of the file</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Positioning modes for <code class="code">seek_...</code><br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALseek_fd"></a>seek_fd : <code class="type">?whence:<a href="Cash.html#TYPEseek_command">seek_command</a> -> <a href="Cash.html#TYPEfd">fd</a> -> int -> int</code></pre><pre><span class="keyword">val</span> <a name="VALseek_in"></a>seek_in : <code class="type">?whence:<a href="Cash.html#TYPEseek_command">seek_command</a> -> Pervasives.in_channel -> int -> int</code></pre><pre><span class="keyword">val</span> <a name="VALseek_out"></a>seek_out : <code class="type">?whence:<a href="Cash.html#TYPEseek_command">seek_command</a> -> Pervasives.out_channel -> int -> int</code></pre><div class="info">
Reposition the I/O cursor for a file descriptor or channel.  This gives the
<code class="code">Unix.lseek</code> functionality applied to fd's and channels.  Not all such values
are seekable; this is dependent on the OS implementation.  The return value is
the resulting position of the I/O cursor in the I/O stream.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtell_fd"></a>tell_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALtell_in"></a>tell_in : <code class="type">Pervasives.in_channel -> int</code></pre><pre><span class="keyword">val</span> <a name="VALtell_out"></a>tell_out : <code class="type">Pervasives.out_channel -> int</code></pre><div class="info">
Return the position of the I/O cursor in the the I/O stream.  Not all file
descriptors or channels support cursor-reporting; this is dependent on the OS
implementation.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEfile_perm"></a>file_perm = <code class="type">int</code> </code>
<br>
<br><code><span class="keyword">type</span> <a name="TYPEopen_flag"></a>open_flag = <code class="type">Unix.open_flag</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_RDONLY</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Open for reading</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_WRONLY</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Open for writing</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_RDWR</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Open for reading and writing</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_NONBLOCK</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Open in non-blocking mode</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_APPEND</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Open for append</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_CREAT</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Create if nonexistent</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_TRUNC</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Truncate to 0 length if existing</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_EXCL</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Fail if existing</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_NOCTTY</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Don't make this dev a controlling tty</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_DSYNC</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Writes complete as `Synchronised I/O data integrity completion'</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_SYNC</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Writes complete as `Synchronised I/O file integrity completion'</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">O_RSYNC</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Reads complete as writes (depending on O_SYNC/O_DSYNC)</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
The flags to <code class="code">open_file_...</code>.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALopen_file_out"></a>open_file_out : <code class="type">?perms:<a href="Cash.html#TYPEfile_perm">file_perm</a> -><br>       string -> <a href="Cash.html#TYPEopen_flag">open_flag</a> list -> Pervasives.out_channel</code></pre><pre><span class="keyword">val</span> <a name="VALopen_file_in"></a>open_file_in : <code class="type">?perms:<a href="Cash.html#TYPEfile_perm">file_perm</a> -><br>       string -> <a href="Cash.html#TYPEopen_flag">open_flag</a> list -> Pervasives.in_channel</code></pre><div class="info">
<code class="code">open_file_...</code> <i>~perms fname flags</i>: <i>perms</i> defaults to <code class="code">0o666</code>.
  <i>flags</i> is a list of <code class="code">open_flag</code>s.  You must use exactly one of the
  <code class="code">O_RDONLY</code>, <code class="code">O_WRONLY</code>, or <code class="code">O_RDWR</code> flags.
<p>

  Caml do not have input/output channels, so it's one or the other. (You can
  hack simultaneous I/O on a file by opening it R/W, taking the result input
  channel, and duping it to an output channel with <code class="code">out_channel_of_dup_in</code>.)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALopen_fdes"></a>open_fdes : <code class="type">?perms:<a href="Cash.html#TYPEfile_perm">file_perm</a> -> string -> <a href="Cash.html#TYPEopen_flag">open_flag</a> list -> <a href="Cash.html#TYPEfd">fd</a></code></pre><div class="info">
Same as <code class="code">open_file_{in,out}</code>, but returns a file descriptor.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALopen_input_file"></a>open_input_file : <code class="type">?flags:<a href="Cash.html#TYPEopen_flag">open_flag</a> list -> string -> Pervasives.in_channel</code></pre><pre><span class="keyword">val</span> <a name="VALopen_output_file"></a>open_output_file : <code class="type">?flags:<a href="Cash.html#TYPEopen_flag">open_flag</a> list -><br>       ?perms:<a href="Cash.html#TYPEfile_perm">file_perm</a> -> string -> Pervasives.out_channel</code></pre><div class="info">
These are equivalent to <code class="code">open_file_...</code>, after adding the
  read/write mode to the <code class="code">flags</code> argument to <code class="code">O_RDONLY</code> or <code class="code">O_WRONLY</code>,
  respectively (so don't use them).  <code class="code">Flags</code> defaults to [] for
  <code class="code">open_input_file</code>, and <code class="code">[O_CREAT; O_TRUNC]</code> for <code class="code">open_output_file</code>.  These
  procedures are for compatibility with Scsh, and the defaults make the
  procedures backwards-compatible with their Scheme standard unary definitions.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALopenfile"></a>openfile : <code class="type">string -> <a href="Cash.html#TYPEopen_flag">open_flag</a> list -> <a href="Cash.html#TYPEfile_perm">file_perm</a> -> Unix.file_descr</code></pre><div class="info">
For Cash proper operation, you must use this openfile in place of the Unix
  one; ours calls <code class="code">Unix.set_close_on_exec</code> on the returned file_descr, to make
  all the channel-mapping machinery work smoothly.<br>
</div>
<br>
The 6 procedures below are for compatibility with Scheme.<br><br>
<pre><span class="keyword">val</span> <a name="VALwith_input_from_file"></a>with_input_from_file : <code class="type">string -> (unit -> 'a) -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALwith_output_to_file"></a>with_output_to_file : <code class="type">string -> (unit -> 'a) -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALwith_errors_to_file"></a>with_errors_to_file : <code class="type">string -> (unit -> 'a) -> 'a</code></pre><div class="info">
The file named by the first argument is opened for input or output, an input
 or output channel connected to it is made into <code class="code">stdin</code>, <code class="code">stdout</code> or <code class="code">stderr</code>
 (see <code class="code">with_std...</code> in <a href="Cash.html#withstd"><i>Channel manipulation and standard channels</i></a>) and the thunk is called.  When it
 returns, the channel is closed and the previous default is restored.  The value
 yielded by the thunk is returned.
<p>

 Note: the open functions used are <code class="code">Pervasives.open_{in,out}</code>.  If you need
 <code class="code">open_file_{in,out}</code>, it's easy enough to cook up your own wrapper with
 <code class="code">unwind_protect</code> and <code class="code">with_std...</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALcall_with_input_file"></a>call_with_input_file : <code class="type">string -> (Pervasives.in_channel -> 'a) -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALcall_with_output_file"></a>call_with_output_file : <code class="type">string -> (Pervasives.out_channel -> 'a) -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALcall_with_fdes_fn"></a>call_with_fdes_fn : <code class="type">?perms:<a href="Cash.html#TYPEfile_perm">file_perm</a> -><br>       string -> <a href="Cash.html#TYPEopen_flag">open_flag</a> list -> (<a href="Cash.html#TYPEfd">fd</a> -> 'a) -> 'a</code></pre><div class="info">
<code class="code">call_with_...</code> <i>.. filename .. proc</i> call <i>proc</i> with a channel or fd
  opened on <i>filename</i>.  This channel or fd is closed before returning the
  value yielded by <i>proc</i>.  The open procedures used are
  <code class="code">Pervasives.open_{in,out}</code> and <a href="Cash.html#VALopen_fdes"><code class="code">open_fdes</code></a>.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEfdes_flags"></a>fdes_flags =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">FD_CLOEXEC</span></code></td>

</tr></table>

<br>
<pre><span class="keyword">val</span> <a name="VALfdes_flags_fd"></a>fdes_flags_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfdes_flags">fdes_flags</a> list</code></pre><pre><span class="keyword">val</span> <a name="VALfdes_flags_in"></a>fdes_flags_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEfdes_flags">fdes_flags</a> list</code></pre><pre><span class="keyword">val</span> <a name="VALfdes_flags_out"></a>fdes_flags_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEfdes_flags">fdes_flags</a> list</code></pre><pre><span class="keyword">val</span> <a name="VALset_fdes_flags_fd"></a>set_fdes_flags_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfdes_flags">fdes_flags</a> list -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_fdes_flags_in"></a>set_fdes_flags_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEfdes_flags">fdes_flags</a> list -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_fdes_flags_out"></a>set_fdes_flags_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEfdes_flags">fdes_flags</a> list -> unit</code></pre><div class="info">
These procedures allow reading and writing of an open file's flags.  The
only such flag defined by Posix is <code class="code">FD_CLOEXEC</code>; your Unix implementation may
provide others. 
<p>

These procedures should not be particularly useful to the programmer, as the
Cash runtime already provides automatic control of the close-on-exec property,
as long as you don't use <code class="code">Unix.open_file</code> without using <code class="code">Unix.set_close_on_exec</code>
immediately (<a href="Cash.html#VALopenfile"><code class="code">openfile</code></a> does it for you) -- this is the second
incompatibility with <code class="code">Unix</code> (the first being <code class="code">Unix.{in,out}_channel_of_descr</code>).
Unrevealed channels always have their file descriptors marked close-on-exec, as
they can be closed when the Cash process execs a new program.  Whenever the user
reveals or unreveals a channel's file descriptor, the runtime automatically sets
or clears the flag for the programmer.  Programmers that manipulate this flag
should be aware of these extra, automatic operations.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfdes_status_fd"></a>fdes_status_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEopen_flag">open_flag</a> list</code></pre><pre><span class="keyword">val</span> <a name="VALfdes_status_in"></a>fdes_status_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEopen_flag">open_flag</a> list</code></pre><pre><span class="keyword">val</span> <a name="VALfdes_status_out"></a>fdes_status_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEopen_flag">open_flag</a> list</code></pre><pre><span class="keyword">val</span> <a name="VALset_fdes_status_fd"></a>set_fdes_status_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEopen_flag">open_flag</a> list -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_fdes_status_in"></a>set_fdes_status_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEopen_flag">open_flag</a> list -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_fdes_status_out"></a>set_fdes_status_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEopen_flag">open_flag</a> list -> unit</code></pre><div class="info">
These procedures allow reading and writing of an open file's status flags
 (see table below).  Note that this file-descriptor state is shared between file
descriptors created by <code class="code">dup_..</code> (and <code class="code">fork...</code>) --- if you create channel <i>b</i>
by applying <code class="code">dup_...</code> to channel <i>a</i>, and change <i>b</i>'s status flags, you
will also have changed <i>a</i>'s status flags.<br>
</div>
<br>
Status flags for <code class="code">open_file_...</code>, <code class="code">fdes_status_...</code> and
<code class="code">set_fdes_status_...</code>.<br><br>
<br>
<pre>                Allowed operations              Status flag
                --------------------------------------------------------------
Open+Get+Set    These flags can be used         O_APPEND
                in open_file_...,               O_NONBLOCK
                fdes_status_... and             O_SYNC          (...SYNC aren't
                set_fdes_status_... calls       O_DSYNC         impl. in 3.04)
                                                O_RSYNC
                --------------------------------------------------------------
Open+Get        These flags can be used         O_RDONLY
                in open_file_... and            O_WRONLY
                fdes_status_... calls, but are  O_RDWR
                ignored by set_fdes_status_... 
                --------------------------------------------------------------
Open            These flags are only relevant   O_CREAT
                for open_file_... calls; they   O_EXCL
                are ignored by fdes_status_...  O_NOCTTY       (not impl. in 3.04)
                and set_fdes_status_... calls.  O_TRUNC</pre><br><br>
<pre><span class="keyword">val</span> <a name="VALpipe"></a>pipe : <code class="type">unit -> Pervasives.in_channel * Pervasives.out_channel</code></pre><div class="info">
Returns two channels, the read and write end-points of a Unix pipe.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_input"></a>fold_input : <code class="type">('a -> 'b -> 'a) -> 'a -> ('c -> 'b) -> 'c -> 'a</code></pre><div class="info">
<code class="code">fold_input</code> <i>f init reader source</i> is a folder in the sort of
  List.fold_left, but instead of folding a 'a list, you give it a <i>reader</i>
  function (such as <code class="code">read_line</code>), and a <i>source</i> (as <code class="code">stdin</code>).  The elements
  to fold are computed by applying <i>read_line</i> to the <i>source</i>. For
  directories, see <a href="Cash.html#VALfold_directory"><code class="code">fold_directory</code></a> and <a href="Cash.html#VALdirectory_files"><code class="code">directory_files</code></a>.<br>
</div>
<br>
Note about the <code class="code">read_string...</code> procedures: the ones with a <code class="code">?src:fd</code>
argument (default to fd 0, and) directly use <code class="code">Unix.read</code>.  But those with a
<code class="code">?src:in_channel</code> argument (default to <code class="code">stdin</code>, and) use <code class="code">Pervasives.input</code>;
this is to permit seamless mixing of calls to these procedures and Pervasives
I/O operations.  For large blocks of data, it might be more efficient to use
<code class="code">read_string ~src:(fd_of_in_channel chan)</code>, since there's no buffering, but
mixing this with Pervasives may require synchronization (<code class="code">seek_in</code>) which is to
your charge.  Similar considerations apply to write_string...<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEerror_packet"></a>error_packet =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Sys__error</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Unix__error</span> <span class="keyword">of</span> <code class="type">(Unix.error * string * string)</code></code></td>

</tr></table>

<br>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONString_io_error"></a>String_io_error <span class="keyword">of</span> <code class="type">(<a href="Cash.html#TYPEerror_packet">error_packet</a> * string * string * int * int * int)</code></pre>
<div class="info">
This is the exception raised by the
read_string.../write_string... procedures.  It contains the original
error_packet, the name of the procedure, the string the operation has been
attempted on, the start index, the index upto which data has already been
read/written, the end_ index.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALread_string"></a>read_string : <code class="type">?src:<a href="Cash.html#TYPEfd">fd</a> -> int -> string</code></pre><pre><span class="keyword">val</span> <a name="VALread_string_in"></a>read_string_in : <code class="type">?src:Pervasives.in_channel -> int -> string</code></pre><pre><span class="keyword">val</span> <a name="VALread_string_bang"></a>read_string_bang : <code class="type">?src:<a href="Cash.html#TYPEfd">fd</a> -> ?start:int -> ?end_:int -> string -> int</code></pre><pre><span class="keyword">val</span> <a name="VALread_string_bang_in"></a>read_string_bang_in : <code class="type">?src:Pervasives.in_channel -> ?start:int -> ?end_:int -> string -> int</code></pre><div class="info">
These calls read exactly as much data as you requested, unless there is not
enough data (eof).  <code class="code">read_string_bang...</code> <i>str</i> reads the data into string <i>str</i> at the indices in the half-open interval [<i>start</i>,<i>end_</i>); the default
interval is the whole string: <i>start</i> <code class="code">= 0</code> and <i>end_</i> <code class="code">= String.length</code> <i>str</i>.  They will persistently retry on partial reads and when interrupted until
(1) error, (2) eof, or (3) the input request is completely satisfied.  Partial
reads can occur when reading from an intermittent source, such as a pipe or tty.
<p>

<code class="code">read_string{,in}</code> returns the string read; <code class="code">read_string_bang...</code> returns the
number of characters read. They both raise <code class="code">End_of_file</code> at eof.  A request to
read zero bytes returns immediately, with no eof check.
<p>

The values of <code class="code">start</code> and <code class="code">end_</code> must specify a well-defined interval in <code class="code">str</code>,
i.e., <code class="code">0 &lt;= start &lt;= end_ &lt;= String.length str</code>.
<p>

Any partially-read data is included in the error exception packet.  Error
returns on non-blocking input are considered an error.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALread_string_partial"></a>read_string_partial : <code class="type">?src:<a href="Cash.html#TYPEfd">fd</a> -> int -> string</code></pre><pre><span class="keyword">val</span> <a name="VALread_string_partial_in"></a>read_string_partial_in : <code class="type">?src:Pervasives.in_channel -> int -> string</code></pre><pre><span class="keyword">val</span> <a name="VALread_string_bang_partial"></a>read_string_bang_partial : <code class="type">?src:<a href="Cash.html#TYPEfd">fd</a> -> ?start:int -> ?end_:int -> string -> int</code></pre><pre><span class="keyword">val</span> <a name="VALread_string_bang_partial_in"></a>read_string_bang_partial_in : <code class="type">?src:Pervasives.in_channel -> ?start:int -> ?end_:int -> string -> int</code></pre><div class="info">
These are atomic best-effort/forward-progress calls.  Best effort: they may
read less than you request if there is a lesser amount of data immediately
available (<i>e.g.</i>, because you are reading from a pipe or a tty).  Forward
progress: if no data is immediately available (<i>e.g.</i>, empty pipe), they will
block.  Therefore, if you request an <i>n &gt; 0</i> byte read, while you may not get
everything you asked for, you will always get something (barring eof).
<p>

There is one case in which the forward-progress guarantee is cancelled: when the
programmer explicitly sets the channel to non-blocking i/o.  In this case, if no
data is immediately available, the procedure will not block, but will
immediately return a zero-byte read.
<p>

<code class="code">read_string_partial{,in}</code> reads the data into a freshly allocated string, which
it returns as its value.  <code class="code">read_string_bang_partial...</code> <i>str</i> reads the data
into string <i>str</i> at the indices in the half-open interval [<code class="code">start</code>,<code class="code">end_</code>);
the default interval is the whole string: <code class="code">start = 0</code> and <code class="code">end_ = String.length
string</code>.  It returns the number of bytes read.
<p>

The values of <code class="code">start</code> and <code class="code">end_</code> must specify a well-defined interval in <code class="code">str</code>,
i.e., <code class="code">0 &lt;= start &lt;= end_ &lt;= String.length str</code>.
<p>

A request to read zero bytes returns immediatedly, with no eof check.
<p>

In sum, there are only three ways you can get a zero-byte read: (1) you request
one, (2) you turn on non-blocking i/o, or (3) you try to read at eof (but then
End_of_file is raised).
<p>

These are the routines to use for non-blocking input.  They are also useful when
you wish to efficiently process data in large blocks, and your algorithm is
insensitive to the block size of any particular read operation.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwrite_string"></a>write_string : <code class="type">?dst:<a href="Cash.html#TYPEfd">fd</a> -> ?start:int -> ?end_:int -> string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALwrite_string_out"></a>write_string_out : <code class="type">?dst:Pervasives.out_channel -> ?start:int -> ?end_:int -> string -> unit</code></pre><div class="info">
These procedures write all the data requested. 
 If the procedure cannot perform the write with a single kernel call (due to
interrupts or partial writes), it will perform multiple write operations until
all the data is written or an error has occurred.  A non-blocking i/o error is
considered an error.  (Error exception packets for this syscall include the
amount of data partially transferred before the error occurred.)
<p>

In <code class="code">write_string...</code> <i>str</i>, the data written are the characters of the string
<i>str</i> in the half-open interval [<i>start</i>,<i>end_</i>).  The default interval
is the whole string: <i>start</i> <code class="code">= 0</code> and <i>end_</i> <code class="code">= String.length string</code>.  The
values of <code class="code">start</code> and <code class="code">end_</code> must specify a well-defined interval in <code class="code">str</code>,
i.e., <code class="code">0 &lt;= start &lt;= end_ &lt;= String.length str</code>.
<p>

A zero-byte write returns immediately, with no error.
<p>

Output to buffered channels: <code class="code">write-string</code>'s efforts end as soon as all the
data has been placed in the output buffer.  Errors and true output may not
happen until a later time, of course.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwrite_string_partial"></a>write_string_partial : <code class="type">?dst:<a href="Cash.html#TYPEfd">fd</a> -> ?start:int -> ?end_:int -> string -> int</code></pre><pre><span class="keyword">val</span> <a name="VALwrite_string_partial_out"></a>write_string_partial_out : <code class="type">?dst:Pervasives.out_channel -> ?start:int -> ?end_:int -> string -> int</code></pre><div class="info">
These routines are the atomic best-effort/forward-progress analog to
<code class="code">write_string...</code>. They return the number of bytes written, which may be less
than you asked for.  Partial writes can occur when (1) we write off the physical
end of the media, (2) the write is interrrupted, or (3) the file descriptor is
set for non-blocking i/o.
<p>

If the file descriptor is not set up for non-blocking i/o, then a successful
return from these procedures makes a forward progress guarantee --- that is, a
partial write took place of at least one byte:<ul>
<li>If we are at the end of physical media, and no write takes place, an error
  exception is raised.  So a return implies we wrote <em>something</em>.</li>
<li>If the call is interrupted after a partial transfer, it returns immediately.
  But if the call is interrupted before any data transfer, then the write is
  retried.</li>
</ul>

If we request a zero-byte write, then the call immediately returns 0.  If the
file descriptor is set for non-blocking i/o, then the call may return 0 if it
was unable to immediately write anything (<i>e.g.</i>, full pipe).  Barring these
two cases, a write either returns <i>nwritten</i> &gt; 0, or raises an error
exception.
<p>

Contrarily to Scsh, non-blocking i/o is also available on buffered channels.  Doing
non-blocking i/o to a buffered channel is well-defined: if a Sys_blocked_io
encapsulated exception is raised, the bufuer is full and writing one character
would block.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEselectable"></a>selectable =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Nothing</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Read_in</span> <span class="keyword">of</span> <code class="type">Pervasives.in_channel</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Read_fd</span> <span class="keyword">of</span> <code class="type"><a href="Cash.html#TYPEfd">fd</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Write_out</span> <span class="keyword">of</span> <code class="type">Pervasives.out_channel</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Write_fd</span> <span class="keyword">of</span> <code class="type"><a href="Cash.html#TYPEfd">fd</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Except_in</span> <span class="keyword">of</span> <code class="type">Pervasives.in_channel</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Except_fd</span> <span class="keyword">of</span> <code class="type"><a href="Cash.html#TYPEfd">fd</a></code></code></td>

</tr></table>

<div class="info">
The kind of things you can ask to <code class="code">select</code>.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALselect_bang"></a>select_bang : <code class="type">?timeout:float -> <a href="Cash.html#TYPEselectable">selectable</a> array -> int * int * int</code></pre><pre><span class="keyword">val</span> <a name="VALselect"></a>select : <code class="type">?timeout:float -> <a href="Cash.html#TYPEselectable">selectable</a> array -> <a href="Cash.html#TYPEselectable">selectable</a> array</code></pre><div class="info">
The <code class="code">select</code> procedure allows a process to block and wait for events on
    multiple I/O channels. 
The <i>selectable</i> argument is an array of <code class="code">Read_in</code> or <code class="code">Except_in</code> input
channels and <code class="code">Read_fd</code> or <code class="code">Except_fd</code> integer file descriptors, and <code class="code">Write_out</code>
output channels and <code class="code">Write_fd</code> integer file descriptors.  The procedure returns
an array whose elements are a subset of the array argument.  In this result
array, every <code class="code">Read_in</code> or <code class="code">Read_fd</code> element of is ready for input; every
<code class="code">Write_out</code> or <code class="code">Write_fd</code> element is ready for output; every <code class="code">Except_in</code> or
<code class="code">Except_fd</code> element has an exceptional condition pending.
<p>

The <code class="code">select</code> call will block until at least one of the I/O channels passed to it
is ready for operation.  The <i>timeout</i> value can be used to force the call to
time-out after a given number of seconds. Its default means wait indefinitely. A
zero value can be used to poll the I/O channels.
<p>

If an Unix I/O channel appears more than once in the selectable argument ---
perhaps occuring once as a Caml channel, and once as the channel's underlying
integer file descriptor --- only one of these two references may appear in the
returned vector.  Buffered I/O channels are handled specially --- if an input
channel's buffer is not empty, or an output channel's buffer is not yet full,
then these channels are immediately considered eligible for I/O without using
the actual, primitive <code class="code">select</code> system call to check the underlying file
descriptor.  This works pretty well for buffered input channels, but is a little
problematic for buffered output channels.
<p>

The <code class="code">select_bang</code> procedure is similar, but indicates the subset of active I/O
channels by side-effecting the argument array.  Non-active I/O channels in the
argument array are overwritten with <code class="code">Nothing</code> values.
<p>

The call returns the number of active elements remaining in the array.  As a
convenience, the vectors passed in to <code class="code">select_bang</code> are allowed to contain
<code class="code">Nothing</code> values as well as integers and channels.
<p>

<i>Remark:</i> I (Olin) have found the <code class="code">select_bang</code> interface to be the more
useful of the two. After the system call, it allows you to check a specific I/O
channel in constant time.<br>
</div>
<br>
<br>
<a name="3_BufferedIO"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Buffered I/O</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Caml channels use buffered I/O --- data is transferred to or from the OS in
blocks. Cash provides control of this mechanism: the programmer may force
saved-up output data to be transferred to the OS when he chooses, and may also
choose which I/O buffering policy to employ for a given channel (or turn
buffering off completely).
<p>

It can be useful to turn I/O buffering off in some cases, for example when an
I/O stream is to be shared by multiple subprocesses.  For this reason, Cash
allocates an unbuffered channel for file descriptor 0 at start-up time.  Because
shells frequently share stdin with subprocesses, if the shell does buffered
reads, it might ``steal'' input intended for a subprocess.  For this reason, all
shells, including sh, csh, scsh and cash, read stdin unbuffered.  Applications
that can tolerate buffered input on stdin can reset <code class="code">stdin</code> to block buffering
for higher performance.
<p>

There are three buffering policies that may be chosen:<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEbufpolicy"></a>bufpolicy =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Block</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>General block buffering (general default).</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Line</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Line buffering (tty default).</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Nobuf</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Direct I/O --- no buffering.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<br>
<br>
The line buffering policy flushes output whenever a newline is output;
whenever the buffer is full; or whenever an input is read from stdin.  Line
buffering is the default for channels open on terminal devices.  <i>Oops:
Pervasives I/O implementation doesn't support it, so line buffering is not
implemented.</i><br><br>
<pre><span class="keyword">val</span> <a name="VALset_chan_buffering_in"></a>set_chan_buffering_in : <code class="type">Pervasives.in_channel -> ?size:int -> <a href="Cash.html#TYPEbufpolicy">bufpolicy</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_chan_buffering_out"></a>set_chan_buffering_out : <code class="type">Pervasives.out_channel -> ?size:int -> <a href="Cash.html#TYPEbufpolicy">bufpolicy</a> -> unit</code></pre><div class="info">
<code class="code">set_chan_buffering_...</code> <i>channel</i> <code class="code">~size:</code><i>size policy</i> allows the
programmer to assign a particular I/O buffering policy to a channel, and to
choose the size of the associated buffer.
<p>

The <i>size</i> argument requests an I/O buffer of <i>size</i> bytes.  If not given, a
reasonable default is used; if given and zero, buffering is turned off (i.e.,
<code class="code">~size:0</code> for any policy is equivalent to <i>policy</i> = <code class="code">Nobuf</code>).
<p>

Implementation notes: you can't set a size lower than the actual contents of the
buffer; so you may have to flush out_channels, or only use it on new
in_channels, i.e., before I/O is performed on the channel.  You can't set a size
higher than the current standard size (4 Kb) yet.  The <code class="code">Nobuf</code> policy is
emulated by a buffer of size 1.  With Ocaml 3.04, <code class="code">set_chan_buffering_in</code> is
ineffective.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALforce_output"></a>force_output : <code class="type">Pervasives.out_channel -> unit</code></pre><div class="info">
This procedure flushes buffered output, and raises a write-error exception on error.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALflush_all_chans"></a>flush_all_chans : <code class="type">unit -> unit</code></pre><div class="info">
This procedure flushes all open output channels with buffered data.<br>
</div>
<br>
<br>
<a name="2_Filesystem"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">File system</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Besides the following procedures, which allow access to the computer's file
system, Cash also provides a set of procedures which manipulate file <i>names</i>.
These string-processing procedures are documented in section <a href="Cash.html#filenames"><i>Manipulating file names</i></a>.<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEoverride"></a>override =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Don't</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Delete</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Query</span></code></td>

</tr></table>

<br>
<pre><span class="keyword">val</span> <a name="VALcreate_directory"></a>create_directory : <code class="type">?perms:<a href="Cash.html#TYPEfile_perm">file_perm</a> -> ?override:<a href="Cash.html#TYPEoverride">override</a> -> string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALcreate_fifo"></a>create_fifo : <code class="type">?perms:<a href="Cash.html#TYPEfile_perm">file_perm</a> -> ?override:<a href="Cash.html#TYPEoverride">override</a> -> string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALcreate_hard_link"></a>create_hard_link : <code class="type">?override:<a href="Cash.html#TYPEoverride">override</a> -> string -> string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALcreate_symlink"></a>create_symlink : <code class="type">?override:<a href="Cash.html#TYPEoverride">override</a> -> string -> string -> unit</code></pre><div class="info">
These procedures create objects of various kinds in the file system.
<p>

The <i>~override</i> argument controls the action if there is already an object in
the file system with the new name:<ul>
<li><code class="code">Don't</code> (override): signal an error (default)</li>
<li><code class="code">Query</code>: prompt the user</li>
<li><code class="code">Delete</code>: delete the old object (with <code class="code">delete_file</code> or <code class="code">delete_directory,</code> as
  appropriate) before creating the new object.</li>
</ul>

<i>Perms</i> defaults to <code class="code">0o777</code> (but is masked by the current umask).
<p>

Note: currently, if you try to create a hard or symbolic link from a file to
itself, you will error out with <i>~override</i> <code class="code">Don't</code>, and simply delete your
file with <i>~override</i> <code class="code">Delete</code>. Catching this will require some sort of
true-name procedure, which Cash (nor Scsh) currently do not have.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdelete_file"></a>delete_file : <code class="type">string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALdelete_directory"></a>delete_directory : <code class="type">string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALdelete_filesys_object"></a>delete_filesys_object : <code class="type">string -> bool</code></pre><div class="info">
These procedures delete objects from the file system.  The
<code class="code">delete_filesys_object</code> procedure will delete an object of any type from the
file system: files, (empty) directories, symlinks, fifos, <i>etc.</i>
<p>

If the object being deleted doesn't exist, <code class="code">delete_directory</code> and <code class="code">delete_file</code>
raise an error, while <code class="code">delete_filesys_object</code> simply returns.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALread_symlink"></a>read_symlink : <code class="type">string -> string</code></pre><div class="info">
Return the filename referenced by symbolic link <code class="code">fname</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrename_file"></a>rename_file : <code class="type">?override:<a href="Cash.html#TYPEoverride">override</a> -> string -> string -> unit</code></pre><div class="info">
When using <code class="code">rename_file</code> <i>old_fname new_fname</i>, if you override an
existing object, then <i>old_fname</i> and <i>new_fname</i> must type-match --- either
both directories, or both non-directories.  This is required by the semantics of
Unix <code class="code">rename()</code>.
<p>

Note: there is an unfortunate atomicity problem with the <code class="code">rename_file</code>
procedure: if you specify <code class="code">~override:Don't</code>, but create file <i>new_fname</i>
sometime between <code class="code">rename_file</code>'s existence check and the actual rename
operation, your file will be clobbered with <i>old_fname</i>. There is no way to
fix this problem, given the semantics of Unix <code class="code">rename()</code>; at least it is highly
unlikely to occur in practice.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_file_mode_fn"></a>set_file_mode_fn : <code class="type">string -> <a href="Cash.html#TYPEfile_perm">file_perm</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_file_mode_fd"></a>set_file_mode_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfile_perm">file_perm</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_file_mode_in"></a>set_file_mode_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEfile_perm">file_perm</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_file_mode_out"></a>set_file_mode_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEfile_perm">file_perm</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_file_owner_fn"></a>set_file_owner_fn : <code class="type">string -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_file_owner_fd"></a>set_file_owner_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_file_owner_in"></a>set_file_owner_in : <code class="type">Pervasives.in_channel -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_file_owner_out"></a>set_file_owner_out : <code class="type">Pervasives.out_channel -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_file_group_fn"></a>set_file_group_fn : <code class="type">string -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_file_group_fd"></a>set_file_group_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_file_group_in"></a>set_file_group_in : <code class="type">Pervasives.in_channel -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_file_group_out"></a>set_file_group_out : <code class="type">Pervasives.out_channel -> int -> unit</code></pre><div class="info">
These procedures set the permission bits, owner id, and group id of a file,
respectively.  The file can be specified by using a file name: <code class="code">set_file_..._fn</code>
<i>filename</i>, or either an integer file descriptor: <code class="code">set_file_..._fd</code> <i>fd</i> or
a channel: <code class="code">set_file_..._{in,out}</code> <i>channel</i> open on the file.  Setting file
user ownership usually requires root privileges.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_file_times"></a>set_file_times : <code class="type">?times:float * float -> string -> unit</code></pre><div class="info">
This procedure sets the access and modified times for the file to the
supplied values (see around <a href="Cash.html#VALdate"><code class="code">date</code></a> for the Cash representation of time).
If the <i>~times</i> argument is not supplied, they are both taken to be the
current time.  You must provide both times or neither.  If the procedure
completes successfully, the file's time of last status-change (<code class="code">ctime</code>) is set
to the current time.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsync_file_fd"></a>sync_file_fd : <code class="type">int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsync_file_out"></a>sync_file_out : <code class="type">Pervasives.out_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsync_file_system"></a>sync_file_system : <code class="type">unit -> unit</code></pre><div class="info">
Calling <code class="code">sync_file_...</code> causes Unix to update the disk data structures for a
given file.  For <code class="code">sync_file_out</code>, any buffered data the channel may have is first
flushed.  Calling <code class="code">sync_file_system</code> synchronises the kernel's entire file
system with the disk.
<p>

These procedures are not Posix.  Interestingly enough, <code class="code">sync_file_system</code>
doesn't actually do what it is claimed to do.  We just threw it in for humor
value.  See the <code class="code">sync(2)</code> man page for Unix enlightenment.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtruncate_file_fn"></a>truncate_file_fn : <code class="type">string -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALtruncate_file_fd"></a>truncate_file_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALtruncate_file_in"></a>truncate_file_in : <code class="type">Pervasives.in_channel -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALtruncate_file_out"></a>truncate_file_out : <code class="type">Pervasives.out_channel -> int -> unit</code></pre><div class="info">
<code class="code">truncate_file_...</code> <i>fname/file descriptor/channel len</i> truncates the
    specified file is to <i>len</i> bytes in length.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEfile_kind"></a>file_kind = <code class="type">Unix.file_kind</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">S_REG</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">S_DIR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">S_CHR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">S_BLK</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">S_LNK</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">S_FIFO</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">S_SOCK</span></code></td>

</tr></table>

<br>
<br><code><span class="keyword">type</span> <a name="TYPEfile_info"></a>file_info = <code class="type">Unix.stats</code> = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_dev&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_ino&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_kind&nbsp;: <code class="type"><a href="Cash.html#TYPEfile_kind">file_kind</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_perm&nbsp;: <code class="type"><a href="Cash.html#TYPEfile_perm">file_perm</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_nlink&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_uid&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_gid&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_rdev&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_size&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_atime&nbsp;: <code class="type">float</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_mtime&nbsp;: <code class="type">float</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>st_ctime&nbsp;: <code class="type">float</code>;</code></td>

</tr></table>
}

<div class="info">
What is returned by <code class="code">file_info_...</code>.  An alias for <code class="code">Unix.stats</code>.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALfile_info_fn"></a>file_info_fn : <code class="type">?chase:bool -> string -> <a href="Cash.html#TYPEfile_info">file_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_info_fd"></a>file_info_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfile_info">file_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_info_in"></a>file_info_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEfile_info">file_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_info_out"></a>file_info_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEfile_info">file_info</a></code></pre><div class="info">
The <code class="code">file_info_...</code> procedures return a record structure containing
everything there is to know about a file. <code class="code">file_info_fn</code> takes a <i>~chase</i>
flag; if it's is true (the default), then the procedure chases symlinks and
reports on the files to which they refer. If <i>~chase</i> is false, then the
procedure checks the actual file itself, even if it's a symlink.<br>
</div>
<br>
The following procedures all return selected information about a file; they
are built on top of <code class="code">file_info_...</code>, and are called with the same arguments that
are passed to it.<br><br>
<pre><span class="keyword">val</span> <a name="VALfile_type_fn"></a>file_type_fn : <code class="type">?chase:bool -> string -> <a href="Cash.html#TYPEfile_kind">file_kind</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_type_fd"></a>file_type_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfile_kind">file_kind</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_type_in"></a>file_type_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEfile_kind">file_kind</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_type_out"></a>file_type_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEfile_kind">file_kind</a></code></pre><div class="info">
Return the type of fn/fd/channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_inode_fn"></a>file_inode_fn : <code class="type">?chase:bool -> string -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_inode_fd"></a>file_inode_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_inode_in"></a>file_inode_in : <code class="type">Pervasives.in_channel -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_inode_out"></a>file_inode_out : <code class="type">Pervasives.out_channel -> int</code></pre><div class="info">
Return the inode of fn/fd/channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_mode_fn"></a>file_mode_fn : <code class="type">?chase:bool -> string -> <a href="Cash.html#TYPEfile_perm">file_perm</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_mode_fd"></a>file_mode_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEfile_perm">file_perm</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_mode_in"></a>file_mode_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEfile_perm">file_perm</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_mode_out"></a>file_mode_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEfile_perm">file_perm</a></code></pre><div class="info">
Return the mode bits (permissions, setuid, setgid) of fn/fd/channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_nlinks_fn"></a>file_nlinks_fn : <code class="type">?chase:bool -> string -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_nlinks_fd"></a>file_nlinks_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_nlinks_in"></a>file_nlinks_in : <code class="type">Pervasives.in_channel -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_nlinks_out"></a>file_nlinks_out : <code class="type">Pervasives.out_channel -> int</code></pre><div class="info">
Return the number of hard links to this fn/fd/channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_owner_fn"></a>file_owner_fn : <code class="type">?chase:bool -> string -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_owner_fd"></a>file_owner_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_owner_in"></a>file_owner_in : <code class="type">Pervasives.in_channel -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_owner_out"></a>file_owner_out : <code class="type">Pervasives.out_channel -> int</code></pre><div class="info">
Return the owner of fn/fd/channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_group_fn"></a>file_group_fn : <code class="type">?chase:bool -> string -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_group_fd"></a>file_group_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_group_in"></a>file_group_in : <code class="type">Pervasives.in_channel -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_group_out"></a>file_group_out : <code class="type">Pervasives.out_channel -> int</code></pre><div class="info">
Return the group id of fn/fd/channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_size_fn"></a>file_size_fn : <code class="type">?chase:bool -> string -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_size_fd"></a>file_size_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_size_in"></a>file_size_in : <code class="type">Pervasives.in_channel -> int</code></pre><pre><span class="keyword">val</span> <a name="VALfile_size_out"></a>file_size_out : <code class="type">Pervasives.out_channel -> int</code></pre><div class="info">
Return the size in bytes of fn/fd/channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_last_access_fn"></a>file_last_access_fn : <code class="type">?chase:bool -> string -> float</code></pre><pre><span class="keyword">val</span> <a name="VALfile_last_access_fd"></a>file_last_access_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> float</code></pre><pre><span class="keyword">val</span> <a name="VALfile_last_access_in"></a>file_last_access_in : <code class="type">Pervasives.in_channel -> float</code></pre><pre><span class="keyword">val</span> <a name="VALfile_last_access_out"></a>file_last_access_out : <code class="type">Pervasives.out_channel -> float</code></pre><div class="info">
Return the time of last access of fn/fd/channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_last_mod_fn"></a>file_last_mod_fn : <code class="type">?chase:bool -> string -> float</code></pre><pre><span class="keyword">val</span> <a name="VALfile_last_mod_fd"></a>file_last_mod_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> float</code></pre><pre><span class="keyword">val</span> <a name="VALfile_last_mod_in"></a>file_last_mod_in : <code class="type">Pervasives.in_channel -> float</code></pre><pre><span class="keyword">val</span> <a name="VALfile_last_mod_out"></a>file_last_mod_out : <code class="type">Pervasives.out_channel -> float</code></pre><div class="info">
Return the time of last modification of fn/fd/channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_last_status_change_fn"></a>file_last_status_change_fn : <code class="type">?chase:bool -> string -> float</code></pre><pre><span class="keyword">val</span> <a name="VALfile_last_status_change_fd"></a>file_last_status_change_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> float</code></pre><pre><span class="keyword">val</span> <a name="VALfile_last_status_change_in"></a>file_last_status_change_in : <code class="type">Pervasives.in_channel -> float</code></pre><pre><span class="keyword">val</span> <a name="VALfile_last_status_change_out"></a>file_last_status_change_out : <code class="type">Pervasives.out_channel -> float</code></pre><div class="info">
Return the time of last status change of fn/fd/channel.<br>
</div>
<br>
Example
<pre><code class="code">      (* All my files in /usr/tmp: *)
        with_cwd "/usr/tmp"
          (fun () -&gt; List.filter (fun f -&gt; file_owner_fn f = user_uid())
            (directory_files "."))
</code></pre><br><br>
<br>
The following procedures are file-type predicates that test the type of a
given file.  They are applied to the same arguments to which <code class="code">file_info_...</code> is
applied; the sole exception is <code class="code">file_symlink_fn</code>, which does not take the
optional <i>chase</i> second argument.  For example,
 <pre><code class="code">       is_file_directory_fn "/usr/dalbertz"          =&gt; true</code></pre><br><br>
<pre><span class="keyword">val</span> <a name="VALis_file_directory_fn"></a>is_file_directory_fn : <code class="type">?chase:bool -> string -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_directory_fd"></a>is_file_directory_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_directory_in"></a>is_file_directory_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_directory_out"></a>is_file_directory_out : <code class="type">Pervasives.out_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_fifo_fn"></a>is_file_fifo_fn : <code class="type">?chase:bool -> string -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_fifo_fd"></a>is_file_fifo_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_fifo_in"></a>is_file_fifo_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_fifo_out"></a>is_file_fifo_out : <code class="type">Pervasives.out_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_regular_fn"></a>is_file_regular_fn : <code class="type">?chase:bool -> string -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_regular_fd"></a>is_file_regular_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_regular_in"></a>is_file_regular_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_regular_out"></a>is_file_regular_out : <code class="type">Pervasives.out_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_socket_fn"></a>is_file_socket_fn : <code class="type">?chase:bool -> string -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_socket_fd"></a>is_file_socket_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_socket_in"></a>is_file_socket_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_socket_out"></a>is_file_socket_out : <code class="type">Pervasives.out_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_special_fn"></a>is_file_special_fn : <code class="type">?chase:bool -> string -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_special_fd"></a>is_file_special_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_special_in"></a>is_file_special_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_special_out"></a>is_file_special_out : <code class="type">Pervasives.out_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_symlink_fn"></a>is_file_symlink_fn : <code class="type">string -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_symlink_fd"></a>is_file_symlink_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_symlink_in"></a>is_file_symlink_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_symlink_out"></a>is_file_symlink_out : <code class="type">Pervasives.out_channel -> bool</code></pre><br><code><span class="keyword">type</span> <a name="TYPEaccessibility"></a>accessibility =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Accessible</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Access permitted.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Unaccessible</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Can't stat --- a protected directory is blocking access.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Permission</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Permission denied.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">No_directory</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Some directory doesn't exist.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Nonexistent</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>File doesn't exist.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
The following <code class="code">is_file_not_...</code> procedures return this accessibility
information about a named file/file descriptor/channel.<br>
</div>
<br>
<br>
A file is considered writeable if either (1) it exists and is writeable or
(2) it doesn't exist and the directory is writeable.  Since symlink permission
bits are ignored by the filesystem, these calls do not take a <i>chase</i> flag.
<p>

Note that these procedures use the process' <em>effective</em> user and group ids for
permission checking.  Posix defines an <code class="code">access()</code> function that uses the
process' real uid and gids. This is handy for setuid programs that would like to
find out if the actual user has specific rights; Cash ought to provide this
functionality (but doesn't at the current time).  
<p>

There are several problems with these procedures. First, there's an atomicity
issue. In between checking permissions for a file and then trying an operation
on the file, another process could change the permissions, so a return value
from these functions guarantees nothing. Second, the code special-cases
permission checking when the uid is root --- if the file exists, root is assumed
to have the requested permission.  However, not even root can write a file that
is on a read-only file system, such as a CD ROM. In this case,
<code class="code">is_file_not_writable_...</code> will lie, saying that root has write access, when in
fact the opening the file for write access will fail.  Finally, write permission
confounds write access and create access.  These should be disentangled.
<p>

Some of these problems could be avoided if Posix had a real-uid variant of the
<code class="code">access()</code> call we could use, but the atomicity issue is still a problem. In the
final analysis, the only way to find out if you have the right to perform an
operation on a file is to try and open it for the desired operation. These
permission-checking functions are mostly intended for script-writing, where
loose guarantees are tolerated.<br><br>
<pre><span class="keyword">val</span> <a name="VALis_file_not_readable_fn"></a>is_file_not_readable_fn : <code class="type">string -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><pre><span class="keyword">val</span> <a name="VALis_file_not_readable_fd"></a>is_file_not_readable_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><pre><span class="keyword">val</span> <a name="VALis_file_not_readable_in"></a>is_file_not_readable_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><pre><span class="keyword">val</span> <a name="VALis_file_not_readable_out"></a>is_file_not_readable_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><pre><span class="keyword">val</span> <a name="VALis_file_not_writable_fn"></a>is_file_not_writable_fn : <code class="type">string -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><pre><span class="keyword">val</span> <a name="VALis_file_not_writable_fd"></a>is_file_not_writable_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><pre><span class="keyword">val</span> <a name="VALis_file_not_writable_in"></a>is_file_not_writable_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><pre><span class="keyword">val</span> <a name="VALis_file_not_writable_out"></a>is_file_not_writable_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><pre><span class="keyword">val</span> <a name="VALis_file_not_executable_fn"></a>is_file_not_executable_fn : <code class="type">string -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><pre><span class="keyword">val</span> <a name="VALis_file_not_executable_fd"></a>is_file_not_executable_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><pre><span class="keyword">val</span> <a name="VALis_file_not_executable_in"></a>is_file_not_executable_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><pre><span class="keyword">val</span> <a name="VALis_file_not_executable_out"></a>is_file_not_executable_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEaccessibility">accessibility</a></code></pre><br>
The following <code class="code">is_file_...</code> procedures are the logical negation of the
preceding <code class="code">is_file_not_...</code>  procedures. Refer to them for a discussion of their
problems and limitations.<br><br>
<pre><span class="keyword">val</span> <a name="VALis_file_readable_fn"></a>is_file_readable_fn : <code class="type">string -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_readable_fd"></a>is_file_readable_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_readable_in"></a>is_file_readable_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_readable_out"></a>is_file_readable_out : <code class="type">Pervasives.out_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_writable_fn"></a>is_file_writable_fn : <code class="type">string -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_writable_fd"></a>is_file_writable_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_writable_in"></a>is_file_writable_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_writable_out"></a>is_file_writable_out : <code class="type">Pervasives.out_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_executable_fn"></a>is_file_executable_fn : <code class="type">string -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_executable_fd"></a>is_file_executable_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_executable_in"></a>is_file_executable_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_executable_out"></a>is_file_executable_out : <code class="type">Pervasives.out_channel -> bool</code></pre><br><code><span class="keyword">type</span> <a name="TYPEexisting"></a>existing =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Existing</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Exists.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Unexisting</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Doesn't exist.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Search_denied</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Some protected directory is blocking the search.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
What the following <code class="code">file_not_exists_...</code> return.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALfile_not_exists_fn"></a>file_not_exists_fn : <code class="type">?chase:bool -> string -> <a href="Cash.html#TYPEexisting">existing</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_not_exists_fd"></a>file_not_exists_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEexisting">existing</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_not_exists_in"></a>file_not_exists_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEexisting">existing</a></code></pre><pre><span class="keyword">val</span> <a name="VALfile_not_exists_out"></a>file_not_exists_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEexisting">existing</a></code></pre><br>
The logical negations of the preceding functions.<br><br>
<pre><span class="keyword">val</span> <a name="VALis_file_existing_fn"></a>is_file_existing_fn : <code class="type">?chase:bool -> string -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_existing_fd"></a>is_file_existing_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_existing_in"></a>is_file_existing_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_existing_out"></a>is_file_existing_out : <code class="type">Pervasives.out_channel -> bool</code></pre><br>
<br>
<a name="2_Directoriesglobbingandtempfiles"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Directories, globbing and temp files</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALfold_directory"></a>fold_directory : <code class="type">('a -> string -> 'a) -> 'a -> string -> 'a</code></pre><div class="info">
<code class="code">fold_directory</code> folds the file names of a directory in the same way as
  <a href="Cash.html#VALfold_input"><code class="code">fold_input</code></a>, <em>except</em> `<code class="code">.</code>' and `<code class="code">..</code>'.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdirectory_files"></a>directory_files : <code class="type">?dot_files:bool -> string -> string list</code></pre><div class="info">
<code class="code">directory_files</code> <i>dir</i> return the list of files in directory <i>dir</i>.
  The <i>~dot_files</i> flag (default false) causes dot files to be included in the
  list.  Regardless of the value of <i>~dot_files</i>, the two files <code class="code">.</code> and <code class="code">..</code>
  are <em>never</em> returned.
<p>

  The directory <i>dir</i> is not prepended to each file name in the result
  list. That is, <code class="code">directory_files "/etc"</code> returns
   <pre><code class="code">    ["chown"; "exports"; "fstab"; ...]</code></pre> <em>not</em>
   <pre><code class="code">    ["/etc/chown"; "/etc/exports"; "/etc/fstab"; ...]</code></pre>
<p>

  To use the files in returned list, the programmer can either manually prepend
  the directory:
    <pre><code class="code">    List.map (fun f -&gt; file_name_as_directory dir ^ f) (directory_files dir) </code></pre>
  or cd to the directory before using the file names:
    <pre><code class="code">    with_cwd dir (fun () -&gt; List.iter delete_file (directory_files ".")) </code></pre>
  or use the <code class="code">glob</code> procedure, defined below.
<p>

  A directory list can be generated by <code class="code">run_with_strings (fun () -&gt; exec_path
  "ls" [])</code>, but this is unreliable, as filenames with whitespace in their
  names will be split into separate entries. Using <code class="code">directory_files</code> is
  reliable.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALglob"></a>glob : <code class="type">string list -> string list</code></pre><div class="info">
<code class="code">glob [</code><i>patterns</i><code class="code">]</code> glob each pattern against the filesystem and
return the sorted list.  Duplicates are not removed. Patterns matching nothing
are not included literally. (Why bother to mention such a silly possibility?
Because that is what sh does.)  C shell {a,b,c} patterns are
expanded. Backslash quotes characters, turning off the special meaning of {,
}, *, [, ] and ?.
<p>

Note that the rules of backslash for Caml strings and glob patterns work
together to require four backslashes in a row to specify a single literal
backslash. Fortunately, it is very rare that a backslash occurs in a Unix file
name.
<p>

A glob subpattern will not match against dot files unless the first character of
the subpattern is a literal ``<code class="code">.</code>''.  Further, a dot subpattern will not match
the files <code class="code">.</code> or <code class="code">..</code> unless it is a constant pattern, as in <code class="code">glob "../*/*.c"</code>.
So a directory's dot files can be reliably generated with the simple glob
pattern <code class="code">".*"</code>. Some examples:
<pre><code class="code">  (* All the C and #include files in my directory. *)
    glob ["*.c"; "*.h"] </code></pre>
<pre><code class="code">  (* All the C files in this directory and its immediate subdirectories. *)
    glob ["*.c"; "*/*.c"] </code></pre>
<pre><code class="code">  (* All the C files in the lexer and parser dirs. *)
    glob ["lexer/*.c"; "parser/*.c"]
    glob ["{lexer,parser}/*.c"] </code></pre>
<pre><code class="code">  (* All the C files in the strange directory "{lexer,parser}". *)
    glob "\{lexer,parser\}/*.c"] </code></pre>
<pre><code class="code">  (* All the files ending in "*", e.g., ["foo*"; "bar*"] *)
     glob ["*\\*"] </code></pre>
<pre><code class="code">   (* All files containing the string "lexer",
      e.g., ["mylexer.c"; "lexer1.notes"] *)
     glob ["*lexer*"] </code></pre>
<pre><code class="code">   (* Either ["lexer"] or []. *)
     glob ["lexer"] </code></pre>
<p>

If the first character of the pattern (after expanding braces) is a slash, the
search begins at root; otherwise, the search begins in the current working
directory.
<p>

If the last character of the pattern (after expanding braces) is a slash, then
the result matches must be directories, <i>e.g.</i>,
<pre><code class="code">    glob ["/usr/man/man?/"]          =&gt; ["/usr/man/man1/"; "/usr/man/man2/"; ...] </code></pre>
<p>

Globbing can sometimes be useful when we need a list of a directory's files
where each element in the list includes the pathname for the file.  Compare:
<pre><code class="code">    directory_files "../include/*"   =&gt; ["cig.h"; "decls.h"; ...]
    glob ["../include/*"]      =&gt; ["../include/cig.h"; "../include/decls.h"; ...]
</code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALglob_quote"></a>glob_quote : <code class="type">string -> string</code></pre><div class="info">
<code class="code">glob_quote</code> <i>str</i> returns a constant glob pattern that exactly matches <i>str</i>.  All wild-card characters in <i>str</i> are quoted with a backslash.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEfile_match_pattern"></a>file_match_pattern =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">String_pat</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Regexp_pat</span> <span class="keyword">of</span> <code class="type">Pcre.regexp</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Predicate_pat</span> <span class="keyword">of</span> <code class="type">(string -> bool)</code></code></td>

</tr></table>

<br>
<pre><span class="keyword">val</span> <a name="VALfile_match"></a>file_match : <code class="type">?dot_files:bool -> string -> <a href="Cash.html#TYPEfile_match_pattern">file_match_pattern</a> list -> string list</code></pre><div class="info">
<code class="code">file_match</code> <i>root [pat</i><sub class="subscript">1</sub><i>; pat</i><sub class="subscript">2</sub><i>; ...]</i> provides a more
    powerful file-matching service, at the expense of a less convenient
    notation. It is intermediate in power between most shell matching machinery
    and recursive <code class="code">find(1)</code>.
<p>

Each <code class="code">String_pat</code> or <code class="code">Regexp_pat</code> pattern is a regexp. The procedure searches
from <i>root</i>, matching the first-level files against pattern <i>pat</i><sub class="subscript">1</sub>, the
second-level files against <i>pat</i><sub class="subscript">2</sub>, and so forth.  The list of files
matching the whole path pattern is returned, in sorted order.
<p>

The files <code class="code">.</code> and <code class="code">..</code> are never matched. Other dot files are only matched if
the <i>~dot_files</i> argument is <code class="code">true</code>.
<p>

A given <i>pat</i><sub class="subscript">i</sub> pattern is matched as a regexp, so it is not forced to
match the entire file name. E.g., pattern <code class="code">"t"</code> matches any file containing a
``t'' in its name, while pattern <code class="code">"^t$"</code> matches only a file whose entire name
is ``<code class="code">t</code>''.
<p>

 The <i>pat</i><sub class="subscript">i</sub> patterns can be more general than stated above.<ul>
<li>A single pattern can specify multiple levels of the path by embedding <code class="code">/</code>
  characters within the pattern. For example, the pattern <code class="code">"a/b/c"</code> gives a
  match equivalent to the list of patterns <code class="code">"a"; "b"; "c"</code>.</li>
</ul>
<ul>
<li>A <code class="code">Predicate_pat</code> pattern is a procedure, which is used as a match
  predicate. It will be repeatedly called with a candidate file-name to
  test. The file-name will be the entire path accumulated. If the procedure
  raises an error condition, <code class="code">file_match</code> will catch the error and treat it as a
  failed match. This keeps <code class="code">file_match</code> from being blown out of the water by
  applying tests to dangling symlinks and other similar situations.</li>
</ul>

Some examples:
<p>

<pre><code class="code"> file_match "/usr/lib" [String_pat "m$"; String_pat "^tab"]
     =&gt; ["/usr/lib/term/tab300"; "/usr/lib/term/tab300-12"; ...] </code></pre>
<pre><code class="code"> file_match "." [String_pat "^lex|parse|codegen$"; String_pat "\\\\.c$"]
     =&gt; ["lex/lex.c"; "lex/lexinit.c"; "lex/test.c"; "parse/actions.c";
     "parse/error.c"; "parse/test.c"; "codegen/io.c"; "codegen/walk.c"] </code></pre>
<pre><code class="code"> file_match "."  [String_pat "^lex|parse|codegen$/\\\\.c$")
     =&gt; (* The same. *) </code></pre>
<pre><code class="code"> file_match "." [Predicate_pat is_file_directory_fn]
     =&gt; (* All subdirs of the current directory. *) </code></pre>
<pre><code class="code"> file_match "/" [Predicate_pat is_file_directory_fn]
    =&gt; ["/bin"; "/dev"; "/etc"; "/tmp"; "/usr"]
       (* All subdirs of root. *) </code></pre>
<pre><code class="code"> file_match "."  [String_pat "\\\\.c"]
    =&gt; (* All the C files in my directory. *) </code></pre>
<pre><code class="code"> let ext extension = fun fn -&gt; String_13.has_suffix fn extension in
 let trew _ -&gt; true in
 file_match "." [String_pat "./\\\\.c"];
 file_match "." [String_pat ""; String_pat "\\\\.c"];
 file_match "." [Predicate_pat trew; String_pat "\\\\.c"];
 file_match "." [Predicate_pat trew; Predicate_pat (ext ".c")]
    =&gt; (* All the C files of all my immediate subdirs. *) </code></pre>
<pre><code class="code"> file_match "." ["lexer"]
    =&gt; ["mylexer.c"; "lexer.notes"]
       (* Compare with glob ["lexer"], above. *) </code></pre>
<p>

Note that when <i>root</i> is the current working directory (<code class="code">"."</code>), when it is
converted to directory form, it becomes <code class="code">""</code>, and doesn't show up in the result
file-names.
<p>

It is regrettable that the regexp wild card char, ``<code class="code">.</code>'', is such an important
file name literal, as dot-file prefix and extension delimiter.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcreate_temp_file"></a>create_temp_file : <code class="type">?prefix:string -> unit -> string</code></pre><div class="info">
<code class="code">create_temp_file ()</code> creates a new temporary file and return its name.
  The optional argument specifies the filename prefix to use, and defaults to
  <code class="code">"/usr/tmp/</code><i>pid</i><code class="code">"</code>, where <i>pid</i> is the current process' id.  The
  procedure generates a sequence of filenames that have <i>~prefix</i> as a common
  prefix, looking for a filename that doesn't already exist in the file
  system. When it finds one, it creates it, with permission <code class="code">0o600</code> and returns
  the filename. (The file permission can be changed to a more permissive
  permission with <code class="code">set_file_mode</code> after being created).
<p>

This file is guaranteed to be brand new. No other process will have it
open. This procedure does not simply return a filename that is very likely to be
unused. It returns a filename that definitely did not exist at the moment
<code class="code">create_temp_file</code> created it.
<p>

It is not necessary for the process' pid to be a part of the filename for the
uniqueness guarantees to hold. The pid component of the default prefix simply
serves to scatter the name searches into sparse regions, so that collisions
are less likely to occur. This speeds things up, but does not affect
correctness.
<p>

Security note: doing i/o to files created this way in <code class="code">/usr/tmp/</code> is not
necessarily secure. General users have write access to <code class="code">/usr/tmp/</code>, so even if
an attacker cannot access the new temp file, he can delete it and replace it
with one of his own. A subsequent open of this filename will then give you his
file, to which he has access rights. There are several ways to defeat this
attack,<ul>
<li>Use <code class="code">temp_file_iterate</code>, below, to return the file descriptor allocated when
  the file is opened. This will work if the file only needs to be opened once.</li>
<li>If the file needs to be opened twice or more, create it in a protected
  directory, <i>e.g.</i>, <code class="code">$HOME</code>.</li>
<li>Ensure that <code class="code">/usr/tmp</code> has its sticky bit set. This requires system
  administrator privileges.</li>
</ul>
<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_temp_file_template"></a>set_temp_file_template : <code class="type">string * string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALwith_temp_file_template"></a>with_temp_file_template : <code class="type">string * string -> (unit -> 'a) -> 'a</code></pre><div class="info">
The actual default prefix used by <code class="code">create_temp_file</code> and template for
  <code class="code">temp_file_iterate</code> can be overridden for increased security, and is
  controlled by these two procs, which modify it permanently
  (<code class="code">set_temp_file_template</code>) or temporarily (<code class="code">with_temp_file_template</code>).
<p>

This template is a pair of strings used as prefix and suffix for the names; it
defaults to <code class="code">("/usr/tmp/</code><i>pid</i><code class="code">.", "")</code>, where <i>pid</i> is the current process'
process id.  File names are generated by inserting a varying string between
them.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtemp_file_iterate"></a>temp_file_iterate : <code class="type">?template:string * string -> (string -> 'a option) -> 'a</code></pre><div class="info">
This procedure can be used to perform certain atomic transactions on the
 file system involving filenames. Some examples: <ul>
<li>Linking a file to a fresh backup temp name.</li>
<li>Creating and opening an unused, secure temp file.</li>
<li>Creating an unused temporary directory.</li>
</ul>

This procedure uses <i>template</i> to generate a series of trial file names (see
<code class="code">with_temp_file_template</code>).
<p>

The second argument is a <i>maker</i> procedure which is serially called on each
file name generated.  It returns one value wrapped in an option type. If it is
<code class="code">None</code> or if <i>maker</i> raises <code class="code">Unix.Unix_error Unix.EEXIST ...</code>,
<code class="code">temp_file_iterate</code> will loop, generating a new file name and calling <i>maker</i>
again. If the returned value is <code class="code">Some v</code>, the loop is terminated, returning <code class="code">v</code>.
<p>

After a number of unsuccessful trials, <code class="code">temp_file_iterate</code> may give up and
signal an error.
<p>

Thus, if we ignore its optional <i>template</i> argument, <code class="code">create_temp_file</code> could
be defined as:
<pre><code class="code">
  let create_temp_file () =
    let flags = [O_WRONLY; O_CREAT; O_EXCL] in
    temp_file_iterate
      (fun fname -&gt;
         ignore (Io_3_2.close_fd (Io_3_2.open_fdes ~perms:0o600 fname flags)); 
         Some fname)
</code></pre>
<p>

To rename a file to a temporary name:
<pre><code class="code">
  temp_file_iterate 
    ~template: (".#temp.", "")            (* Keep link in cwd. *)
    (fun backup -&gt; create_hard_link old_file backup; Some backup);
  delete_file old_file
</code></pre> Recall that Cash reports syscall failure by raising an error exception, not
by returning an error code. This is critical to to this example --- the
programmer can assume that if the <code class="code">temp_file_iterate</code> call returns, it returns
successully.  So the following <code class="code">delete_file</code> call can be reliably invoked, safe
in the knowledge that the backup link has definitely been established.
<p>

To create a unique temporary directory:
<pre><code class="code">
  temp_file_iterate
    ~template: ("/usr/tmp/tempdir.", "")
    (fun dir -&gt; create_directory dir; Some dir)
</code></pre>
<p>

Similar operations can be used to generate unique symlinks and fifos, or to
return values other than the new filename (<i>e.g.</i>, an open file descriptor or
channel).
<p>

For increased security, a user may wish to change the template to use a
directory not allowing world write access (<i>e.g.</i>, his home directory).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtemp_file_channel"></a>temp_file_channel : <code class="type">unit -> Pervasives.in_channel * Pervasives.out_channel</code></pre><div class="info">
This procedure can be used to provide an interprocess communications channel
 with arbitrary-sized buffering.  It returns two values, an input channel and an
 output channel, both open on a new temp file.  The temp file itself is deleted
 from the Unix file tree before <code class="code">temp_file_channel</code> returns, so the file is
 essentially unnamed, and its disk storage is reclaimed as soon as the two
 channels are closed.
<p>

<code class="code">Temp_file_channel</code> is analogous to <code class="code">pipe</code> with two exceptions:<ul>
<li>If the writer process gets ahead of the reader process, it will not hang
  waiting for some small pipe buffer to drain. It will simply buffer the data on
  disk. This is good.</li>
<li>If the reader process gets ahead of the writer process, it will also not hang
  waiting for data from the writer process. It will simply see and report an end
  of file. This is bad.</li>
</ul>

In order to ensure that an end-of-file returned to the reader is legitimate, the
reader and writer must serialise their i/o. The simplest way to do this is for
the reader to delay doing input until the writer has completely finished doing
output, or exited.<br>
</div>
<br>
<br>
<a name="2_Processes"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Processes</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALexec"></a>exec : <code class="type">string -> string list -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALexec_path"></a>exec_path : <code class="type">string -> string list -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALexec_with_env"></a>exec_with_env : <code class="type">string -> ?env:(string * string) list -> string list -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALexec_path_with_env"></a>exec_path_with_env : <code class="type">string -> ?env:(string * string) list -> string list -> 'a</code></pre><div class="info">
The <code class="code">..._with_env</code> variants take an optional environment as 2d argument.
 The default value is taken to mean the current process' environment (<i>i.e.</i>,
 the value of the <code class="code">external char **environ</code>).
<p>

The path-searching variants search the directories in the list <code class="code">exec_path_list</code>
for the program.  A path-search is not performed if the program name contains a
slash character --- it is used directly. So a program with a name like
<code class="code">"bin/prog"</code> always executes the program <code class="code">bin/prog</code> in the current working
directory. See <code class="code">$PATH</code> and <a href="Cash.html#VALexec_path_list"><code class="code">exec_path_list</code></a>, below.
<p>

All of these procedures flush buffered output and close unrevealed channels before
executing the new binary.  To avoid flushing buffered output, see <code class="code">low_exec</code> below.
<p>

Note that the C <code class="code">exec()</code> procedure allows the zeroth element of the
argument vector to be different from the file being executed, <i>e.g.</i>
<pre><code class="code">  char *argv[] = {"-", "-f", 0};
  exec("/bin/csh", argv, envp); </code></pre>
The Cash <code class="code">exec</code>, <code class="code">exec_path</code>, <code class="code">exec_with_env</code>, and <code class="code">exec_path_with_env</code>
procedures do not give this functionality --- element 0 of the arg vector is
always identical to the <code class="code">prog</code> argument. In the rare case the user wishes to
differentiate these two items, he can use the low-level <code class="code">low_exec</code> and
<code class="code">exec_path_search</code> procedures.  These procedures never return under any
circumstances.  As with any other system call, if there is an error, they raise
an exception.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlow_exec"></a>low_exec : <code class="type">string -> ?env:(string * string) list -> string list -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALexec_path_search"></a>exec_path_search : <code class="type">string -> string list -> string</code></pre><div class="info">
The <code class="code">low_exec</code> procedure is the low-level interface to the system call.
 In <code class="code">low_exec</code> <i>prog ~env arglist</i>, the <i>arglist</i> parameter is a list of
arguments; <i>~env</i>, if any, is a string -&gt; string alist; if none, it means the
current process' environment.  The new program's <code class="code">argv[0]</code> will be taken from
<code class="code">List.hd</code> <i>arglist</i>, <em>not</em> from <i>prog</i>.  <code class="code">low_exec</code> does not flush
buffered output (see <a href="Cash.html#VALflush_all_chans"><code class="code">flush_all_chans</code></a>).
<p>

<code class="code">exec_path_search</code> <i>fname pathlist</i> searches the directories of <i>pathlist</i>
looking for an occurrence of file <i>fname</i>. If no executable file is found, it
raises <code class="code">Not_found</code>. If <i>fname</i> contains a slash character, the path search is
short-circuited, but the procedure still checks to ensure that the file exists
and is executable --- if not, it still raises <code class="code">Not_found</code>.  Users of this
procedure should be aware that it invites a potential race condition: between
checking the file with <code class="code">exec_path_search</code> and executing it with <code class="code">low_exec</code>, the
file's status might change.  The only atomic way to do the search is to loop
over the candidate file names, exec'ing each one and looping when the exec
operation fails.
<p>

See <code class="code">$PATH</code> and <a href="Cash.html#VALexec_path_list"><code class="code">exec_path_list</code></a>, below.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALexit"></a>exit : <code class="type">int -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALlow_exit"></a>low_exit : <code class="type">int -> 'a</code></pre><div class="info">
These procedures terminate the current process with a given exit status.
 The low-level <code class="code">low_exit</code> procedure immediately terminates the process without
 flushing buffered output.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcall_terminally"></a>call_terminally : <code class="type">(unit -> unit) option -> 'a option</code></pre><div class="info">
<code class="code">call_terminally</code> calls its thunk. When the thunk returns, the process
 exits.  Although <code class="code">call_terminally</code> could be implemented as
        <pre><code class="code">    fun thunk -&gt; thunk(); exit 0 </code></pre>
an implementation can take advantage of the fact that this procedure never
returns. For example, a Scheme runtime can start with a fresh stack and also
start with a fresh dynamic environment, where shadowed bindings are
discarded. This can allow the old stack and dynamic environment to be collected
(assuming this data is not reachable through some live continuation).
<p>

Useless to say, this behaviour is not implemented in Caml.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsuspend"></a>suspend : <code class="type">unit -> unit</code></pre><div class="info">
Suspend the current process with a SIGSTOP signal.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfork"></a>fork : <code class="type">unit -> <a href="Cash.html#TYPEproc">proc</a> option</code></pre><pre><span class="keyword">val</span> <a name="VALfork_child"></a>fork_child : <code class="type">(unit -> unit) -> <a href="Cash.html#TYPEproc">proc</a></code></pre><pre><span class="keyword">val</span> <a name="VALlow_fork"></a>low_fork : <code class="type">?child:(unit -> unit) -> unit -> <a href="Cash.html#TYPEproc">proc</a> option</code></pre><div class="info">
<code class="code">fork ()</code> is like C <code class="code">fork()</code>. 
 In the parent process, it returns <code class="code">(Some</code> &lt;the child's <em>process object</em>&gt;<code class="code">)</code>
 (see <a href="Cash.html#procobj"><i>Process objects and process reaping</i></a> for more information on process objects).  In the child
 process, it returns <code class="code">None</code>.
<p>

<code class="code">fork_child</code> <i>thunk</i> only returns in the parent process, returning the child's
<em>process object</em>.  The child process calls <i>thunk</i> and then exits.
<p>

<code class="code">fork</code> and <code class="code">fork_child</code> flush buffered output before forking, and set the child
process to non-interactive. <code class="code">low_fork</code> does not perform this bookkeeping; it
simply forks.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfork_with_pipe"></a>fork_with_pipe : <code class="type">unit -> <a href="Cash.html#TYPEproc">proc</a> option</code></pre><pre><span class="keyword">val</span> <a name="VALfork_child_with_pipe"></a>fork_child_with_pipe : <code class="type">(unit -> unit) -> <a href="Cash.html#TYPEproc">proc</a></code></pre><pre><span class="keyword">val</span> <a name="VALlow_fork_with_pipe"></a>low_fork_with_pipe : <code class="type">?child:(unit -> unit) -> unit -> <a href="Cash.html#TYPEproc">proc</a> option</code></pre><div class="info">
Like <code class="code">fork</code>, <code class="code">fork_child</code> and <code class="code">low_fork</code>, but the parent and child
  communicate via a pipe connecting the parent's <code class="code">stdin</code> to the child's
  stdout. These procedures side-effect the parent by changing his <code class="code">stdin</code>.
<p>

In effect, <code class="code">fork_...with_pipe</code> splice a process into the data stream immediately
upstream of the current process.  This is the basic function for creating
pipelines.  Long pipelines are built by performing a sequence of
<code class="code">fork_child_with_pipe</code> calls.  For example, to create a background two-process
pipe <code class="code">a | b</code>, we write:
 <pre><code class="code">   fork_child (fun () -&gt; fork_child_with_pipe a; b ()) </code></pre>
which returns the process object for <code class="code">b</code>'s process.
<p>

To create a background three-process pipe <code class="code">a | b | c</code>, we write:
 <pre><code class="code">
   fork_child
       (fun () -&gt;
           fork_child_with_pipe a;
           fork_child_with_pipe b;
           c ());; </code></pre>
which returns the process object for <code class="code">c</code>'s process.
<p>

Note that these procedures affect file descriptors, not channels.  That is, the
pipe is allocated connecting the child's file descriptor 1 to the parent's file
descriptor 0.  <em>Any previous Caml channel built over these affected file
descriptors is shifted to a new, unused file descriptor with <code class="code">dup</code> before
allocating the I/O pipe.</em>  This means, for example, that the channels bound to
<code class="code">stdin</code> and <code class="code">stdout</code> in either process are not affected --- they still refer to
the same I/O sources and sinks as before.  Remember the simple Cash rule: Caml
channels are bound to I/O sources and sinks, <em>not</em> particular file
descriptors.
<p>

If the child process wishes to rebind the current <code class="code">stdout</code> to the pipe on file
descriptor 1, it can do this using <code class="code">with_stdout</code> or a related function (see
<a href="Cash.html#withstd"><i>Channel manipulation and standard channels</i></a>).  Similarly, if the parent wishes to change the current <code class="code">stdin</code>
to the pipe on file descriptor 0, it can do this using <code class="code">set_stdin</code> or a related
function.  Here is an example showing how to set up the I/O channels on both
sides of the pipe:
<pre><code class="code">   fork_child_with_pipe
       (fun () -&gt;
          with_stdout (out_channel_of_fd 1)
            (fun () -&gt; print_endline "Hello, world."));
   set_stdin (in_channel_of_fd 0);
   print_endline (read_line stdin);;  (* Read the string output by the child. *) </code></pre>
None of this is necessary when the I/O is performed by an exec'd program in the
child or parent process, only when the pipe will be referenced by Caml code
through one of the default current I/O channels.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfork_with_pipe_plus"></a>fork_with_pipe_plus : <code class="type"><a href="Cash.html#TYPEfd">fd</a> list list -> <a href="Cash.html#TYPEproc">proc</a> option</code></pre><pre><span class="keyword">val</span> <a name="VALfork_child_with_pipe_plus"></a>fork_child_with_pipe_plus : <code class="type">(unit -> 'a) -> <a href="Cash.html#TYPEfd">fd</a> list list -> <a href="Cash.html#TYPEproc">proc</a></code></pre><pre><span class="keyword">val</span> <a name="VALlow_fork_with_pipe_plus"></a>low_fork_with_pipe_plus : <code class="type">?child:(unit -> 'a) -> <a href="Cash.html#TYPEfd">fd</a> list list -> <a href="Cash.html#TYPEproc">proc</a> option</code></pre><div class="info">
Like <code class="code">fork_with_pipe</code> <em>et al.</em>, but the pipe connections between the child
 and parent are specified by a connection list.
<p>

A <i>connect-list</i> is a specification of how the two processes are to be wired
together by pipes.  It has the form <code class="code">((</code><i>from1</i> <i>from2</i> <code class="code">...</code> <i>to</i><code class="code">)
...)</code>.  For example, with
<p>

<pre><code class="code">    [[1; 2; 0]; [3; 1]]</code></pre>
<p>

the first clause <code class="code">[1; 2; 0]</code> causes child's stdout (1) and stderr (2) to be
connected via pipe to parent's stdin (0).  The second clause <code class="code">[3; 1]</code> causes
child's file descriptor 3 to be connected to parent's file descriptor 1.
<p>

<i>Note that all from's are </i><code class="code">out_channel</code><i>s, and all to's are </i><code class="code">in_channel</code><i>s; the child produces, the parent consumes.</i><br>
</div>
<br>
<br>
<a name="procobj"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Process objects and process reaping</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Cash uses <em>process objects</em> to represent Unix processes.
  They are created by the <code class="code">fork</code> procedure, and have the following hidden
  structure:
<pre><code class="code"> type proc = { p_id : int; p_status : Unix.process_status }
</code></pre>
<p>

The only always accessible slot in a proc record is the process' pid, the
integer id assigned by Unix to the process: to get it, use the only (low level)
exported procedure for manipulating process objects: <code class="code">pid_of_proc</code>.<br><br>
<pre><span class="keyword">val</span> <a name="VALpid_of_proc"></a>pid_of_proc : <code class="type"><a href="Cash.html#TYPEproc">proc</a> -> int</code></pre><div class="info">
Extract the process id out of a proc object.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEprobe_pid"></a>probe_pid = <code class="type">Proc_3_4.probe_pid</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Probe</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><em>Signal error condition.</em></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Create</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Create new proc object.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Don't_probe</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Return <code class="code">None</code>.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
The type of the <i>~probe</i> argument to <code class="code">proc_of_pid</code>, that determines what
action to take if there is no process object indexed by the given pid in the
system.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALproc_of_pid"></a>proc_of_pid : <code class="type">?probe:<a href="Cash.html#TYPEprobe_pid">probe_pid</a> -> int -> <a href="Cash.html#TYPEproc">proc</a> option</code></pre><div class="info">
This procedure maps integer Unix process ids to Cash process objects.
 It is intended for use in interactive and debugging code, and is deprecated for
 use in production code.<br>
</div>
<br>
Sometime after a child process terminates, Cash will perform a <code class="code">wait</code> system
call on the child in background, caching the process' exit status in the child's
proc object.  This is called ``reaping'' the process.  Once the child has been
waited, the Unix kernel can free the storage allocated for the dead process'
exit information, so process reaping prevents the process table from becoming
cluttered with un-waited dead child processes (a.k.a. ``zombies'').  This can be
especially severe if the Cash process never waits on child processes at all; if
the process table overflows with forgotten zombies, the OS may be unable to fork
further processes.
<p>

Reaping a child process moves its exit status information from the kernel into
the Cash process, where it is cached inside the child's process object.  If the
Cash user drops all pointers to the process object, it will simply be garbage
collected.  On the other hand, if the Cash program retains a pointer to the
process object, it can use Cash's <code class="code">wait</code> system call to synchronise with the
child and retrieve its exit status multiple times (this is not possible with
simple Unix integer pids in C --- the programmer can only wait on a pid once).
<p>

Thus, process objects allow Cash programmer to do two things not allowed in
other programming environments: <ul>
<li>Subprocesses that are never waited on are still removed from the process
  table, and their associated exit status data is eventually automatically
  garbage collected.</li>
<li>Subprocesses can be waited on multiple times.</li>
</ul>

However, note that once a child has exited, if the Cash programmer drops all
pointers to the child's proc object, the child's exit status will be reaped and
thrown away.  This is the intended behaviour, and it means that integer pids are
not enough to cause a process's exit status to be retained by the Cash runtime.
(This is because it is clearly impossible to GC data referenced by integers.)
<p>

As a convenience for interactive use and debugging, all procedures that take
process objects have corresponding <code class="code">..._pid</code> versions taking integer Unix pids
as arguments, coercing them to the corresponding process objects.  Since integer
process ids are not reliable ways to keep a child's exit status from being
reaped and garbage collected, programmers are encouraged to use process objects
in production code.<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEautoreap_policy"></a>autoreap_policy = <code class="type">Proc_3_4.autoreap_policy</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">No_autoreaping</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Early</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Late</span></code></td>

</tr></table>

<br>
<pre><span class="keyword">val</span> <a name="VALautoreap_policy"></a>autoreap_policy : <code class="type">?policy:<a href="Cash.html#TYPEautoreap_policy">autoreap_policy</a> -> unit -> <a href="Cash.html#TYPEautoreap_policy">autoreap_policy</a></code></pre><div class="info">
The Cash programmer can choose different policies for automatic process
    reaping. 
The policy is determined by using a <i>~policy</i> argument whose values have the
following meaning:<ul>
<li><code class="code">Early</code> (the default):
   The child is reaped from the Unix kernel's process table into Cash as soon as
   it dies. This is done by having a signal handler for the <code class="code">SIGCHLD</code> signal
   reap the process.  <em>If a Cash program sets its own handler for the
   <code class="code">SIGCHLD</code> signal, the handler must reap dead children by calling <code class="code">wait</code>,
   <code class="code">wait_any</code>, or <code class="code">reap_zombies</code>.</em>  <i>Scsh only note: we deprecate
   interrupt-driven code, and hope to provide alternative tools in a future,
   multi-threaded release of Scsh</i>.</li>
<li><code class="code">Late</code>:
   The child is not autoreaped until it dies <em>and</em> the Cash program drops all
   pointers to its process object. That is, the process table is cleaned out
   during garbage collection.  <i>Oops: The </i><code class="code">late</code> <i>policy is not supported
   under the current release of Cash. It requires more sophisticated gc hooks
   than we can get from this release of Caml.</i></li>
<li><code class="code">No_autoreaping</code>:
   If autoreaping is turned off, process reaping is completely under control of
   the programmer, who can force outstanding zombies to be reaped by manually
   calling the <code class="code">reap_zombies</code> procedure (see below).</li>
</ul>

Note that under any of the autoreap policies, a particular process <i>p</i> can be
manually reaped into Cash by simply calling <code class="code">wait</code> <i>p</i>.  <em>All</em> zombies
can be manually reaped with <code class="code">reap_zombies</code>.
<p>

The <code class="code">autoreap_policy</code> procedure returns the policy's previous value.  Calling
<code class="code">autoreap_policy ()</code> returns the current policy without no change.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALreap_zombies"></a>reap_zombies : <code class="type">unit -> bool</code></pre><div class="info">
This procedure reaps all outstanding exited child processes into Cash.  It
returns true if there are no more child processes to wait on, and false if there
are outstanding processes still running or suspended.<br>
</div>
<br>
<br>
<a name="4_Issueswithprocessreaping"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title4"><td><div align=center>
<span class="title4">Issues with process reaping</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Reaping a process does not reveal its process group at the time of death;
this information is lost when the process reaped.  This means that a dead,
reaped process is <em>not eligible</em> as a return value for a future
<code class="code">wait_process_group</code> call.  This is not likely to be a problem for most code, as
programs almost never wait on exited processes by process group.  Process group
waiting is usually applied to <em>stopped</em> processes, which are never reaped.  So
it is unlikely that this will be a problem for most programs.<br><br>
<br>
Automatic process reaping is a useful programming convenience.  However, if
a program is careful to wait for all children, and does not wish automatic
reaping to happen, the programmer can simply turn process autoreaping off.
<p>

Programs that do not wish to use automatic process reaping should be aware that
some Cash routines create subprocesses but do not return the child's proc
object: <a href="Cash.html#VALrun_with_in_channel"><code class="code">run_with_in_channel</code></a>, and related procedures (<code class="code">run_with_strings</code>,
<em>et al.</em>).  Automatic process reaping will clean the child processes created
by these procedures out of the kernel's process table.  If a program doesn't use
process reaping, it should either avoid these forms, or use <code class="code">wait_any</code> to wait
for the children to exit.<br><br>
<br>
<br>
<a name="3_Processwaiting"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Process waiting</span>
</div>
</td>
</tr>
</table>
<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEprocess_status"></a>process_status = <code class="type">Unix.process_status</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">WEXITED</span> <span class="keyword">of</span> <code class="type">int</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">WSIGNALED</span> <span class="keyword">of</span> <code class="type">int</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">WSTOPPED</span> <span class="keyword">of</span> <code class="type">int</code></code></td>

</tr></table>

<br>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONChild_not_ready"></a>Child_not_ready</pre>
<br><code><span class="keyword">type</span> <a name="TYPEwait_flag"></a>wait_flag = <code class="type">Unix.wait_flag</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">WNOHANG</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Raise <code class="code">Child_not_ready</code> immediately if child still active.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">WUNTRACED</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Wait for suspend as well as exit.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<br>
<pre><span class="keyword">val</span> <a name="VALwait"></a>wait : <code class="type">?wflags:<a href="Cash.html#TYPEwait_flag">wait_flag</a> list -> <a href="Cash.html#TYPEproc">proc</a> -> <a href="Cash.html#TYPEprocess_status">process_status</a></code></pre><pre><span class="keyword">val</span> <a name="VALwait_pid"></a>wait_pid : <code class="type">?wflags:<a href="Cash.html#TYPEwait_flag">wait_flag</a> list -> int -> <a href="Cash.html#TYPEprocess_status">process_status</a></code></pre><div class="info">
These procedures wait until a child process exits, and returns its exit
  code. The <i>proc</i> argument to <code class="code">wait</code> is a process object (section
<a href="Cash.html#procobj"><i>Process objects and process reaping</i></a>) or, to <code class="code">wait_pid</code>, an integer process id.  
<p>

They return the child's exit status code (or suspension code, if the <code class="code">WUNTRACED</code>
option is used, see above).  See section <a href="Cash.html#waitcodes"><i>Analysing process status codes</i></a> about querying status
values.
<p>

The <i>flags</i> argument is a list of additional options. See above.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEwait_any"></a>wait_any = <code class="type">Proc_3_4.wait_any</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">None_ready</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">No_children</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Exited</span> <span class="keyword">of</span> <code class="type">(<a href="Cash.html#TYPEproc">proc</a> * <a href="Cash.html#TYPEprocess_status">process_status</a>)</code></code></td>

</tr></table>

<br>
<pre><span class="keyword">val</span> <a name="VALwait_any"></a>wait_any : <code class="type">?wflags:<a href="Cash.html#TYPEwait_flag">wait_flag</a> list -> unit -> <a href="Cash.html#TYPEwait_any">wait_any</a></code></pre><div class="info">
The optional <i>flags</i> argument is as for <code class="code">wait</code>.
 This procedure waits for any child process to exit (or stop, if the <code class="code">WUNTRACED</code>
 flag is used).  If one child has exited, it returns the process' process object
 and status code.  If there are no children left for which to wait,
 <code class="code">No_children</code> is returned.  If the <code class="code">WNOHANG</code> flag is used, and none of the
 children are immediately eligible for waiting, then <code class="code">None_ready</code> is returned.
<p>

<code class="code">wait_any</code> will not return a process that has been previously waited by any
other process-wait procedure (<code class="code">wait</code>, <code class="code">wait_pid</code>, <code class="code">wait_any</code>, and
<code class="code">wait_process_group</code>).  It will return reaped processes that haven't yet been
waited.
<p>

The use of <code class="code">wait_any</code> is deprecated.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALwait_process_group"></a>wait_process_group : <code class="type">?wflags:<a href="Cash.html#TYPEwait_flag">wait_flag</a> list -> <a href="Cash.html#TYPEproc">proc</a> -> <a href="Cash.html#TYPEwait_any">wait_any</a></code></pre><pre><span class="keyword">val</span> <a name="VALwait_process_group_pgrp"></a>wait_process_group_pgrp : <code class="type">?wflags:<a href="Cash.html#TYPEwait_flag">wait_flag</a> list -> int -> <a href="Cash.html#TYPEwait_any">wait_any</a></code></pre><div class="info">
These procedures wait for any child whose process group is <i>proc</i> 
 (a process object, for <code class="code">wait_process_group</code>) or <i>pgrp</i> (an integer process
 group id, for <code class="code">wait_process_group_pgrp</code>).  The <i>flags</i> argument is as for
 <code class="code">wait</code>.
<p>

Note that if the programmer wishes to wait for exited processes by process
group, the program should take care not to use process reaping (section
<a href="Cash.html#procobj"><i>Process objects and process reaping</i></a>, as this loses process group information. However,
most process-group waiting is for stopped processes (to implement job control),
so this is rarely an issue, as stopped processes are not subject to reaping.<br>
</div>
<br>
<br>
<a name="waitcodes"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Analysing process status codes</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
When a child process dies (or is suspended), its parent can call the <code class="code">wait</code>
procedure to recover the exit (or suspension) status of the child.  The exit
status is a small integer that encodes information describing how the child
terminated.  The bit-level format of the exit status is not defined by Posix;
you must use pattern-match to decode it.  However, if a child terminates
normally with exit code 0, Posix does require <code class="code">wait</code> to return an exit status
that is exactly zero.  So <i>status</i> <code class="code">= WEXITED 0</code> is a correct way to test for
non-error, normal termination, <i>e.g.</i>,
<pre><code class="code">   let proc = 
     (fork_child (fun () -&gt; exec_path "rcp" ["cash.tar.gz"; "lambda.csd.hku.hk:"])) 
   in
   if wait proc = WEXITED 0 then delete_file "cash.tar.gz"
</code></pre><br><br>
<br>
<br>
<a name="2_Processstate"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Process state</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALumask"></a>umask : <code class="type">unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALset_umask"></a>set_umask : <code class="type">int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALwith_umask"></a>with_umask : <code class="type">int -> (unit -> 'a) -> 'a</code></pre><div class="info">
The process' current umask is retrieved with <code class="code">umask</code>, and set with
<code class="code">set_umask</code> <i>perms</i>. Calling <code class="code">with_umask</code> <i>perms thunk</i> changes the umask to
<i>perms</i> for the duration of the call to <i>thunk</i>. If <i>thunk</i> raises an
exception, the umask is reset to its external value.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALchdir"></a>chdir : <code class="type">?dir:string -> unit -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALcwd"></a>cwd : <code class="type">unit -> string</code></pre><pre><span class="keyword">val</span> <a name="VALwith_cwd"></a>with_cwd : <code class="type">string -> (unit -> 'a) -> 'a</code></pre><br>
These procedures manipulate the current working directory.  
 The cwd can be changed with <code class="code">chdir</code> (although in most cases, <code class="code">with_cwd</code> is
preferrable).  <code class="code">chdir ()</code> changes the cwd to the user's home directory.
<code class="code">with_cwd</code> <i>dir thunk</i> calls <i>thunk</i> with the cwd temporarily set to <i>dir</i>; when <i>thunk</i> returns, or raises an exception, the cwd is returned to its
original value.<br><br>
<pre><span class="keyword">val</span> <a name="VALpid"></a>pid : <code class="type">unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALparent_pid"></a>parent_pid : <code class="type">unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALprocess_group"></a>process_group : <code class="type">unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALset_process_group"></a>set_process_group : <code class="type">?proc:<a href="Cash.html#TYPEproc">proc</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_process_group_pid"></a>set_process_group_pid : <code class="type">int -> int -> unit</code></pre><div class="info">
<code class="code">pid</code> and <code class="code">parent_pid</code> retrieve the process id for the current process and
    its parent. 
<code class="code">process_group</code> returns the process group of the current process.  A process'
process-group can be set with <code class="code">set_process_group...</code>; the value <i>proc</i> (for
<code class="code">set_process_group_pid</code>, an integer process id) specifies the affected
process. <i>proc</i> defaults to the current process.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEprio"></a>prio = <code class="type">Proc_state_3_5.prio</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Prio_process</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Prio_pgrp</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Prio_user</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Tells to the following <code class="code">priority</code> and <code class="code">set_priority</code> procedures if <i>~who</i>
    is a process id, a process group id or a user id, respectively.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<br>
<pre><span class="keyword">val</span> <a name="VALset_priority"></a>set_priority : <code class="type">?who:<a href="Cash.html#TYPEproc">proc</a> -> <a href="Cash.html#TYPEprio">prio</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_priority_pid"></a>set_priority_pid : <code class="type">int -> <a href="Cash.html#TYPEprio">prio</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALpriority"></a>priority : <code class="type">?who:<a href="Cash.html#TYPEproc">proc</a> -> <a href="Cash.html#TYPEprio">prio</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALpriority_pid"></a>priority_pid : <code class="type">int -> <a href="Cash.html#TYPEprio">prio</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALnice"></a>nice : <code class="type">?proc:<a href="Cash.html#TYPEproc">proc</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALnice_pid"></a>nice_pid : <code class="type">int -> int -> unit</code></pre><div class="info">
These procedures manipulate nice values of processes.  The optional
 arguments of type <code class="code">proc</code> default to the current process.  
The ones of type <code class="code">prio</code> indicate how to interpret the first argument. The <code class="code">int</code>
last arguments/results are the nice values, except for <code class="code">nice...</code>, where it is a
delta to be added to the nice value.  If you insist on using pids, there are
<code class="code">..._pid</code> variants, where the first argument is an integer process id.  The
corresponding Posix procedures are <code class="code">{set,get}priority</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALuser_login_name"></a>user_login_name : <code class="type">unit -> string</code></pre><pre><span class="keyword">val</span> <a name="VALuser_uid"></a>user_uid : <code class="type">unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALuser_effective_uid"></a>user_effective_uid : <code class="type">unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALuser_gid"></a>user_gid : <code class="type">unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALuser_effective_gid"></a>user_effective_gid : <code class="type">unit -> int</code></pre><pre><span class="keyword">val</span> <a name="VALuser_supplementary_gids"></a>user_supplementary_gids : <code class="type">unit -> int array</code></pre><pre><span class="keyword">val</span> <a name="VALset_uid"></a>set_uid : <code class="type">int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_gid"></a>set_gid : <code class="type">int -> unit</code></pre><div class="info">
These routines get and set the effective and real user and group ids.    
 The <code class="code">set_uid</code> and <code class="code">set_gid</code> routines correspond to the Posix <code class="code">setuid()</code> and
 <code class="code">setgid()</code> procedures.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEprocess_times"></a>process_times = <code class="type">Unix.process_times</code> = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>tms_utime&nbsp;: <code class="type">float</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>tms_stime&nbsp;: <code class="type">float</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>tms_cutime&nbsp;: <code class="type">float</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>tms_cstime&nbsp;: <code class="type">float</code>;</code></td>

</tr></table>
}

<div class="info">
The process times are:<ul>
<li><code class="code">tms_utime</code>: user CPU time</li>
<li><code class="code">tms_stime</code>: system CPU time</li>
<li><code class="code">tms_cutime</code>: the sames for all...</li>
<li><code class="code">tms_cstime</code>: ...descendant (terminated) processes</li>
</ul>

Note that CPU time clock resolution is not the same as the real-time clock
resolution provided by <code class="code">time_plus_ticks</code>.  That's Unix.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALprocess_times"></a>process_times : <code class="type">unit -> <a href="Cash.html#TYPEprocess_times">process_times</a></code></pre><div class="info">
Get the process_times of the current process.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcpu_ticks_per_sec"></a>cpu_ticks_per_sec : <code class="type">unit -> int</code></pre><div class="info">
Returns the resolution of the CPU timer in clock ticks per second.
 This can be used to convert the times reported by <code class="code">process_times</code> to ticks.<br>
</div>
<br>
<br>
<a name="2_Userandgroupdatabaseaccess"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">User and group database access</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
These procedures are used to access the user and group databases (<i>e.g.</i>,
the ones traditionally stored in <code class="code">/etc/passwd</code> and <code class="code">/etc/group</code>.)<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEuser_info"></a>user_info = <code class="type">User_group_3_6.user_info</code> = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ui_name&nbsp;: <code class="type">string</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ui_uid&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ui_gid&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ui_home_dir&nbsp;: <code class="type">string</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ui_shell&nbsp;: <code class="type">string</code>;</code></td>

</tr></table>
}

<div class="info">
This record gives the recorded information for a particular user.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALuser_info"></a>user_info : <code class="type">int -> <a href="Cash.html#TYPEuser_info">user_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALuser_info_name"></a>user_info_name : <code class="type">string -> <a href="Cash.html#TYPEuser_info">user_info</a></code></pre><div class="info">
Return a user_info record for this user: an integer uid (for <code class="code">user_info</code>),
 or a string user-name (for <code class="code">user_info_name</code>).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALusername_to_uid"></a>username_to_uid : <code class="type">string -> int</code></pre><pre><span class="keyword">val</span> <a name="VALuid_to_username"></a>uid_to_username : <code class="type">int -> string</code></pre><div class="info">
These two procedures convert integer uid's and user names to the other form.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEgroup_info"></a>group_info = <code class="type">User_group_3_6.group_info</code> = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>gi_name&nbsp;: <code class="type">string</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>gi_gid&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>gi_members&nbsp;: <code class="type">string list</code>;</code></td>

</tr></table>
}

<div class="info">
This record gives the recorded information for a particular group.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALgroup_info"></a>group_info : <code class="type">int -> <a href="Cash.html#TYPEgroup_info">group_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALgroup_info_name"></a>group_info_name : <code class="type">string -> <a href="Cash.html#TYPEgroup_info">group_info</a></code></pre><div class="info">
Return a group_info record for this group: an integer gid (for
  <code class="code">group_info</code>), or a string group-name (for <code class="code">group_info_name</code>).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALgroupname_to_gid"></a>groupname_to_gid : <code class="type">string -> int</code></pre><pre><span class="keyword">val</span> <a name="VALgid_to_groupname"></a>gid_to_groupname : <code class="type">int -> string</code></pre><div class="info">
These two procedures convert integer gid's and group names to the other form.<br>
</div>
<br>
<br>
<a name="2_Accessingcommandlinearguments"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Accessing command-line arguments</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALcommand_line_arguments"></a>command_line_arguments : <code class="type">string list option Pervasives.ref</code></pre><pre><span class="keyword">val</span> <a name="VALcommand_line"></a>command_line : <code class="type">unit -> string list</code></pre><div class="info">
The list of strings <code class="code">command_line_arguments</code> contains the arguments
    passed to the Cash process on the command line.
Calling <code class="code">command_line ()</code> returns the complete <code class="code">argv</code> string list, including the
program. So if we run a Cash program
<pre><code class="code">        /usr/shivers/bin/myls -CF src</code></pre>
then <code class="code">command_line_arguments</code> is
<pre><code class="code">        ["-CF"; "src"] </code></pre>
and <code class="code">command_line ()</code> returns
<pre><code class="code">        ["/usr/shivers/bin/myls"; "-CF"; "src"] </code></pre>
<p>

<i>Oops:</i> <code class="code">command_line_arguments</code> <i>should be a string list ref, sans option.
This is due to the way Ocaml script execution munges Sys.argv: it's done after
ocamlrun argument processing, and just before </i><code class="code">#use</code><i>-ing the script.  No way
to insert</i> <code class="code">command_line_arguments</code> <i>initialization here.  So</i>
<code class="code">!command_line_arguments</code> <i>will be </i><code class="code">None</code> <i>until the first call to</i>
<code class="code">command_line ()</code><i>. To reset things as they should be, use the recipe
described below and forget all this mess.  </i><br>
</div>
<pre><span class="keyword">val</span> <a name="VALmake_command_line_arguments"></a>make_command_line_arguments : <code class="type">unit -> string list</code></pre><div class="info">
Usage: insert the following code in front of your script:
 <pre><code class="code">  let command_line_arguments = ref (make_command_line_arguments ()) </code></pre>
(suppress <code class="code">ref</code> if you don't intend to modify it.)  Then you get the intended
<code class="code">command_line_arguments</code>.  Sorry.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALarg"></a>arg : <code class="type">?default:'a -> 'a list -> int -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALarg_star"></a>arg_star : <code class="type">?default_thunk:(unit -> 'a) -> 'a list -> int -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALargv"></a>argv : <code class="type">?default:string -> int -> string</code></pre><div class="info">
These procedures are useful for accessing arguments from argument lists.
 <code class="code">arg</code> <i>arglist n</i> returns the <i>n</i>th element of <i>arglist</i>.
The index is 1-based.  If <i>n</i> is too large, <i>default</i> is returned; if no <i>default</i>, then an error is signaled.
<p>

<code class="code">arg_star</code> is similar, except that the <i>default-thunk</i> is called to generate
the default value.
<p>

<code class="code">argv</code> <i>n</i> is simply <code class="code">arg (command_line ()) (</code><i>n</i> <code class="code">+ 1)</code>. 
The +1 offset ensures that the two expressions:
<pre><code class="code">   arg !command_line_arguments n;
   argv n </code></pre>
return the same argument (assuming the user has not rebound or modified
<code class="code">command_line_arguments</code>).  Example: 
<pre><code class="code">  if !command_line_arguments = [] then
    fork_child
      (fun () -&gt; 
        exec_path "xterm" ["-n"; host; "-title"; host; "-name"; "xterm_" ^ host])
  else
    let progname = file_name_nondirectory (argv 1) in
    let title = host ^ ":" ^ progname in
    fork_child
      (fun () -&gt;
         exec_path "xterm"
           ("-n" :: title :: "-title" :: title :: "-e" :: !command_line_arguments))
</code></pre><br>
</div>
<br>
A subtlety: when the ocaml interpreter is used to execute a Cash program, the
program name reported in the head of the <code class="code">command_line ()</code> list is the Cash
program, <em>not</em> the interpreter.  For example, if we have a shell script in
file <code class="code">fullecho</code>: <pre><code class="code">        #!/usr/local/bin/cash
        open Cash;;
        List.iter (fun arg -&gt; print_string arg; print_char ' ') (command_line ());;</code></pre>
and we run the program
 <pre><code class="code">        fullecho hello world</code></pre>
the program will print out
 <pre><code class="code">        ./fullecho hello world</code></pre>
not
 <pre><code class="code">        /usr/local/bin/cashtop -I mydir ./fullecho hello world</code></pre>
<i>The </i><code class="code">./</code> <i>prepended to the name of the program is an artifact of the
interactive shell (bash, or some so) on a particular OS --- it may or may not
appear elsewhere.</i>
<p>

This argument line processing ensures that if a Cash program is subsequently
compiled into a standalone executable or byte-compiled to a custom executable,
or even a byte-code dynamically linked file, executable by the ocamlrun virtual
machine, its semantics will be unchanged --- the arglist processing is
invariant. In effect, the
        <code class="code">/usr/local/bin/cash</code>
is not part of the program; it's a specification for the machine to execute the
program on, so it is not properly part of the program's argument list.<br><br>
<br>
<br>
<a name="2_Systemparameters"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">System parameters</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALsystem_name"></a>system_name : <code class="type">unit -> string</code></pre><div class="info">
Returns the name of the host on which we are executing.
 This may be a local name, such as ``solar,'' as opposed to a fully-qualified
 domain name such as ``solar.csie.ntu.edu.tw.''<br>
</div>
<br>
<br>
<a name="2_Signalsystem"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Signal system</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALsignal_process"></a>signal_process : <code class="type"><a href="Cash.html#TYPEproc">proc</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsignal_process_pid"></a>signal_process_pid : <code class="type">int -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsignal_process_group"></a>signal_process_group : <code class="type"><a href="Cash.html#TYPEproc">proc</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsignal_process_group_pgrp"></a>signal_process_group_pgrp : <code class="type">int -> int -> unit</code></pre><div class="info">
These two pair of procedures send signals to a specific process, and all the
  processes in a specific process group, respectively.
The <i>proc</i> arguments are processes, or, for <code class="code">signal_..._pid</code>, integer process
ids.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEitimer"></a>itimer = <code class="type">Unix.interval_timer</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ITIMER_REAL</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>decrements in real time, and sends the signal <code class="code">SIGALRM</code> when
       expired.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ITIMER_VIRTUAL</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>decrements in process virtual time, and sends <code class="code">SIGVTALRM</code> when expired.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ITIMER_PROF</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>(for profiling) decrements both when the process is running and when
         the system is running on behalf of the process; it sends <code class="code">SIGPROF</code> when
         expired.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
The three kinds of interval timers.<br>
</div>
<br>
<br><code><span class="keyword">type</span> <a name="TYPEitimer_status"></a>itimer_status = <code class="type">Unix.interval_timer_status</code> = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>it_interval&nbsp;: <code class="type">float</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Period</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>it_value&nbsp;: <code class="type">float</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Current value of the timer</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
The status of an interval timer<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALitimer"></a>itimer : <code class="type">?newstat:<a href="Cash.html#TYPEitimer_status">itimer_status</a> -> <a href="Cash.html#TYPEitimer">itimer</a> -> <a href="Cash.html#TYPEitimer_status">itimer_status</a></code></pre><div class="info">
This is a straighforward interface to Unix.getitimer (if no <i>newstat</i>) and
 Unix.setitimer.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALpause_until_interrupt"></a>pause_until_interrupt : <code class="type">unit -> unit</code></pre><div class="info">
The name says it all.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsleep"></a>sleep : <code class="type">int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsleep_until"></a>sleep_until : <code class="type">float -> unit</code></pre><div class="info">
The <code class="code">sleep</code> procedure causes the process to sleep for <i>secs</i> seconds.
 The <code class="code">sleep_until</code> procedure causes the process to sleep until <i>time</i> (see
 section <a href="Cash.html#time_date"><i>Time</i></a>).<br>
</div>
<br>
<br>
<a name="time_date"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Time</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Cash's time system is fairly sophisticated, particularly with respect to its
careful treatment of time zones.  However, casual users shouldn't be
intimidated; all of the complexity is optional, and defaulting all the optional
arguments reduces the system to a simple interface.<br><br>
<br>
<br>
<a name="3_Terminology"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Terminology</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
``UTC'' and ``UCT'' stand for ``universal coordinated time,'' which is the
official name for what is colloquially referred to as ``Greenwich Mean Time.''
<p>

Posix allows a single time zone to specify <em>two</em> different offsets from UTC:
one standard one, and one for ``summer time.''  Summer time is frequently some
sort of daylight savings time.
<p>

The Cash time package consistently uses this terminology: we never say ``gmt''
or ``dst;'' we always say ``utc'' and ``summer time.''<br><br>
<br>
<br>
<a name="3_Basicdatatypes"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Basic data types</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
We have two types: <em>time</em> and <em>date</em>.<br><br>
<br>
A <em>time</em> specifies an instant in the history of the universe.  It is location
and time-zone independent.  A time is a real value giving the number of elapsed
seconds since the Unix ``epoch'' (Midnight, January 1, 1970 UTC).  Time values
provide nearly arbitrary time resolution, limited only by the Caml floats (IEEE).
<p>

A <em>date</em> is a name for an instant in time that is specified relative to some
location/time-zone in the world, <i>e.g.</i>:
<p>

    Friday October 31, 1994 3:47:21 pm EST.<br><br>
<br>
Dates provide one-second resolution, and are expressed with the following
record type (a Posix tm struct):<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEdate"></a>date = <code class="type">Time_3_10.date</code> = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>seconds&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Seconds after the minute [0-59].</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>minute&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Minutes after the hour [0-59].</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>hour&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Hours since midnight [0-23].</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>month_day&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Day of the month [1-31].</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>month&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Months since January [0-11].</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>year&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Years since 1900.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>tz_name&nbsp;: <code class="type">string option</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Time-zone name: an optional string.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>tz_secs&nbsp;: <code class="type">int option</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Time-zone offset: an optional integer.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>is_summer&nbsp;: <code class="type">bool option</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Summer (Daylight Savings) time in effect?</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>week_day&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Days since Sunday [0-6].</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>year_day&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Days since Jan. 1 [0-365].</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<br>
<br>
If the <code class="code">tz_secs</code> field is given, it specifies the time-zone's offset from
UTC in seconds. If it is specified, the <code class="code">tz_name</code> and <code class="code">is_summer</code> fields are
ignored when using the date structure to determine a specific instant in time.
<p>

If the <code class="code">tz_name</code> field is given, it is a time-zone string such as <code class="code">"EST"</code> or
<code class="code">"HKT"</code> understood by the OS.  Since Posix time-zone strings can specify dual
standard/summer time-zones (<i>e.g.</i>, "EST5EDT" specifies U.S. Eastern
Standard/Eastern Daylight Time), the value of the <code class="code">is_summer</code> field is used to
resolve the ambiguous boundary cases. For example, on the morning of the Fall
daylight savings change-over, 1:00am--2:00am happens twice. Hence the date 1:30
am on this morning can specify two different seconds; the <code class="code">is_summer</code> flag says
which one.
<p>

A date with <code class="code">tz_name</code> = <code class="code">tz_secs</code> = <code class="code">None</code> is a date that is specified in terms
of the system's current time zone.
<p>

There is redundancy in the <code class="code">date</code> data structure.  For example, the <code class="code">year_day</code>
field is redundant with the <code class="code">month_day</code> and <code class="code">month</code> fields.  Either of these
implies the values of the <code class="code">week_day</code> field.  The <code class="code">is_summer</code> and <code class="code">tz_name</code>
fields are redundant with the <code class="code">tz_secs</code> field in terms of specifying an instant
in time.  This redundancy is provided because consumers of dates may want it
broken out in different ways.  The Cash procedures that produce date records
fill them out completely.  However, when date records produced by the programmer
are passed to Cash procedures, the redundancy is resolved by ignoring some of
the secondary fields.  This is described for each procedure below.<br><br>
<pre><span class="keyword">val</span> <a name="VALmake_date"></a>make_date : <code class="type">?tzn:string -><br>       ?tzs:int -><br>       ?summ:bool -><br>       ?wday:int -> ?yday:int -> int -> int -> int -> int -> int -> int -> <a href="Cash.html#TYPEdate">date</a></code></pre><div class="info">
When making a <code class="code">date</code> record, the last five elements of the record are
 optional; the first three default (<i>tzn, tzs, summ</i>) to <code class="code">None</code>, the last two
(<i>wday, yday</i>) to 0.  This is useful when creating a <code class="code">date</code> record to pass as
an argument to <code class="code">time</code>.<br>
</div>
<br>
<br>
<a name="3_Timezones"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Time zones</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Several time procedures take time zones as arguments. When optional, the
time zone defaults to local time zone. Otherwise the time zone can be one of:<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEtime_zone"></a>time_zone = <code class="type">Time_3_10.time_zone</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Tz_local</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Local time.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Tz_secs</span> <span class="keyword">of</span> <code class="type">int</code></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Seconds of offset from UTC. For example, New York City is -18000 (-5 hours), San Francisco is -28800 (-8 hours).</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Tz_name</span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>A Posix time zone string understood by the OS (<i>i.e.</i>, the sort of time zone assigned to the <code class="code">$TZ</code> environment variable).</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<br>
<br>
An integer time zone gives the number of seconds you must add to UTC to get
time in that zone. It is <em>not</em> ``seconds west'' of UTC --- that flips the sign.
<p>

To get UTC time, use a time zone of either 0 or <code class="code">"UCT0"</code>.<br><br>
<br>
<br>
<a name="3_Procedures"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Procedures</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALtime_plus_ticks"></a>time_plus_ticks : <code class="type">unit -> float</code></pre><pre><span class="keyword">val</span> <a name="VALticks_per_sec"></a>ticks_per_sec : <code class="type">unit -> float</code></pre><div class="info">
The current time, with sub-second resolution.
 Sub-second resolution is not provided by Posix, but is available on many
systems. The time is returned as a float, whose integer part is the number of
elapsed seconds since the Unix epoch, and fractional part corresponds to a
number of sub-second ``ticks.'' The length of a tick may vary from
implementation to implementation; it can be determined from <code class="code">ticks_per_sec ()</code>.
<p>

The system clock is not required to report time at the full resolution given by
<code class="code">ticks_per_sec ()</code>. For example, on BSD, time is reported at 1 micro-second
resolution, so <code class="code">ticks_per_sec ()</code> is 1,000,000. That doesn't mean the system
clock has micro-second resolution.
<p>

If the OS does not support sub-second resolution, the fractional part is always
0, and <code class="code">ticks_per_sec ()</code> returns 1.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdate"></a>date : <code class="type">unit -> <a href="Cash.html#TYPEdate">date</a></code></pre><pre><span class="keyword">val</span> <a name="VALdate_of_time"></a>date_of_time : <code class="type">?tz:<a href="Cash.html#TYPEtime_zone">time_zone</a> -> float -> <a href="Cash.html#TYPEdate">date</a></code></pre><div class="info">
Simple <code class="code">date ()</code> returns the current date, in the local time zone.
<p>

<code class="code">date_of_time</code> <i>~tz time</i> converts the time to the date as specified by the
time zone <i>tz</i>.  <i>tz</i> defaults to local time, and is as described in the
time-zone section.  Use <code class="code">date_of_time ~tz (time ())</code> if you need the current
date in a non-local time zone.
<p>

If the <i>tz</i> argument is an integer, the date's <code class="code">tz_name</code> field is a Posix time
zone of the form ``<code class="code">UTC+</code><i>hh</i><code class="code">:</code><i>mm</i><code class="code">:</code><i>ss</i>''; the trailing <code class="code">:</code><i>mm</i><code class="code">:</code><i>ss</i> portion is deleted if it is zeroes.
<p>

<i>The Posix facility for converting dates to times, <code class="code">mktime ()</code>, has a broken
design: it indicates an error by returning -1, which is also a legal return
value (for date 23:59:59 UCT, 12/31/1969). Cash resolves the ambiguity in a
paranoid fashion: it always reports an error if the underlying Unix facility
returns -1. We feel your pain. </i><br>
</div>
<pre><span class="keyword">val</span> <a name="VALtime"></a>time : <code class="type">unit -> float</code></pre><pre><span class="keyword">val</span> <a name="VALtime_of_date"></a>time_of_date : <code class="type"><a href="Cash.html#TYPEdate">date</a> -> float</code></pre><div class="info">
Simple <code class="code">time ()</code> returns the current time.  <code class="code">time_of_date</code> <i>date</i> converts
a date to a time.
<p>

Note that the input <i>date</i> record is overconstrained.  <code class="code">time</code> ignores <i>date</i>'s <code class="code">week_day</code> and <code class="code">year_day</code> fields.  If the date's <code class="code">tz_secs</code> field is set,
the <code class="code">tz_name</code> and <code class="code">is_summer</code> fields are ignored.
<p>

If the <code class="code">tz_secs</code> field is <code class="code">None</code>, then the time-zone is taken from the <code class="code">tz_name</code>
field. A <code class="code">None</code> value of <code class="code">tz_name</code> means the system's current time zone. When
calculating with time-zones, the date's <code class="code">is_summer</code> field is used to resolve
ambiguities:<ul>
<li><code class="code">Some false</code>: Resolve an ambiguous time in favor of non-summer time.</li>
<li><code class="code">Some true</code>: Resolve an ambiguous time in favor of summer time.</li>
<li><code class="code">None</code>: unspecified (mktime(3) says `the information is not available')</li>
</ul>

The <code class="code">Some</code> bool values are useful in boundary cases during the change-over. For
example, in the Fall, when US daylight savings time changes over at 2:00 am,
1:30 am happens twice --- it names two instants in time, an hour apart.
<p>

Outside of these boundary cases, the <code class="code">is_summer</code> flag is ignored. For example,
if the standard/summer change-overs happen in the Fall and the Spring, then the
value of <code class="code">is_summer</code> is ignored for a January or July date. A January date would
be resolved with standard time, and a July date with summer time, regardless of
the <code class="code">is_summer</code> value.
<p>

The <code class="code">is_summer</code> flag is also ignored if the time zone doesn't have a summer
time --- for example, simple UTC.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstring_of_date"></a>string_of_date : <code class="type"><a href="Cash.html#TYPEdate">date</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALformat_date"></a>format_date : <code class="type">string -> <a href="Cash.html#TYPEdate">date</a> -> string</code></pre><div class="info">
<code class="code">string_of_date</code> formats the date as a 24-character string of the form:
<pre>    Sun Sep 16 01:03:52 1973</pre>
<p>

<code class="code">format_date</code> <i>fmt date</i> formats the date according to the format string <i>fmt</i>. The format string is copied verbatim, except that % characters indicate
conversion specifiers that are replaced by fields from the date record.  The
full set of conversion specifiers supported by <code class="code">format_date</code> is:<ul>
<li>%%  Converted to the % character.</li>
<li>%a  abbreviated weekday name</li>
<li>%A  full weekday name</li>
<li>%b  abbreviated month name</li>
<li>%B  full month name</li>
<li>%c  time and date using the time and date representation for the locale (<code class="code">~X ~x</code>)</li>
<li>%d  day of the month as a decimal number (01-31)</li>
<li>%H  hour based on a 24-hour clock as a decimal number (00-23)</li>
<li>%I  hour based on a 12-hour clock as a decimal number (01-12)</li>
<li>%j  day of the year as a decimal number (001-366)</li>
<li>%m  month as a decimal number (01-12)</li>
<li>%M  minute as a decimal number (00-59)</li>
<li>%p  AM/PM designation associated with a 12-hour clock</li>
<li>%S  second as a decimal number (00-61)</li>
<li>%U  week number of the year; Sunday is first day of week (00-53)</li>
<li>%w  weekday as a decimal number (0-6), where Sunday is 0</li>
<li>%W  week number of the year; Monday is first day of week (00-53)</li>
<li>%x  date using the date representation for the locale</li>
<li>%X  time using the time representation for the locale</li>
<li>%y  year without century (00-99)</li>
<li>%Y  year with century (<i>e.g.</i> 1990)</li>
<li>%Z  time zone name or abbreviation, or no characters if no time zone is determinable</li>
</ul>
<br>
</div>
<br>
Here, there should be a
 <pre><code class="code">       fill_in_date : date -&gt; date; </code></pre>
procedure, but it isn't implemented (yet) in Scsh, so I can't just steal the
code.  Here's the spec anyway:
<p>

This procedure fills in missing, redundant slots in a date record.  In
decreasing order of priority:<ul>
<li><b>year, month, month_day =&gt; year_day</b>: If the <code class="code">year</code>, <code class="code">month</code>, and
  <code class="code">month_day</code> fields are all defined (are all integers), the <code class="code">year_day</code> field is
  set to the corresponding value.</li>
<li><b>year, year_day =&gt; month, month_day</b>: If the <code class="code">month</code> and <code class="code">month_day</code> fields
  aren't set, but the <code class="code">year</code> and <code class="code">year_day</code> fields are set, then <code class="code">month</code> and
  <code class="code">month_day</code> are calculated.</li>
<li><b>year, month, month_day, year_day =&gt; week_day</b>: If either of the above rules
  is able to determine what day it is, the <code class="code">week_day</code> field is then set.</li>
<li><b>tz_secs =&gt; tz_name</b>: If <code class="code">tz_secs</code> is defined, but <code class="code">tz_name</code> is not, it is
  assigned a time-zone name of the form ``<code class="code">UTC+</code><i>hh</i><code class="code">:</code><i>mm</i><code class="code">:</code><i>ss</i>''; the
  trailing <code class="code">:</code><i>mm</i><code class="code">:</code><i>ss</i> portion is deleted if it is zeroes.</li>
<li><b>tz_name, date, is_summer =&gt; tz_secs, is_summer</b>: If the date information is
  provided up to second resolution, <code class="code">tz_name</code> is also provided, and <code class="code">tz_secs</code> is
  not set, then <code class="code">tz_secs</code> and <code class="code">is_summer</code> are set to their correct values.
  Summer-time ambiguities are resolved using the original value of
  <code class="code">is_summer</code>. If the time zone doesn't have a summer time variant, then
  <code class="code">is_summer</code> is set to <code class="code">None</code>.</li>
<li><b>local time, date, is_summer =&gt; tz_name, tz_secs, is_summer</b>: If the date
  information is provided up to second resolution, but no time zone information
  is provided (both <code class="code">tz_anme</code> and <code class="code">tz_secs</code> aren't set), then we proceed as in
  the above case, except the system's current time zone is used.</li>
</ul>
<br><br>
<br>
<br>
<a name="2_Environmentvariables"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Environment variables</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALgetenv"></a>getenv : <code class="type">string -> string</code></pre><pre><span class="keyword">val</span> <a name="VALsetenv"></a>setenv : <code class="type">?sval:string -> string -> unit</code></pre><div class="info">
These functions get and set the process environment, stored in the external
C variable <code class="code">char **environ</code>.  An environment variable <i>var</i> is a string.  If
an environment variable is set to a string <i>sval</i>, then the process' global
environment structure is altered with an entry of the form <code class="code">"</code><i>var</i><code class="code">=</code><i>sval</i><code class="code">"</code>.  If <i>sval</i> is omitted, then any entry for <i>var</i> is deleted.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALalist_of_env"></a>alist_of_env : <code class="type">unit -> (string * string) list</code></pre><div class="info">
The <code class="code">alist_of_env</code> procedure converts the entire environment into
 an alist, <i>e.g.</i>,
<pre><code class="code">
[("TERM", "vt100");
 ("SHELL", "/usr/local/bin/cash"); 
 ("PATH", "/sbin:/usr/sbin:/bin:/usr/bin");
 ("EDITOR", "emacs") ;
 ...] </code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALsetenv_from_alist"></a>setenv_from_alist : <code class="type">(string * string) list -> unit</code></pre><div class="info">
The alist argument is installed as the current Unix environment (<i>i.e.</i>,
 converted to a null-terminated C vector of <code class="code">"</code><i>var</i><code class="code">=</code><i>val</i><code class="code">"</code> strings
 which is assigned to the global <code class="code">char **environ</code>).
<pre><code class="code"> setenv_from_alist
   [("TERM", "vt100");
    ("SHELL", "/usr/local/bin/cash"); 
    ("PATH", "/sbin:/usr/sbin:/bin:/usr/bin");
    ("EDITOR", "emacs") ;
    ...] </code></pre><br>
</div>
<br>
The following three functions help the programmer manipulate alist tables in
some generally useful ways. They are all defined using <code class="code">=</code> for key comparison.<br><br>
<pre><span class="keyword">val</span> <a name="VALalist_delete"></a>alist_delete : <code class="type">'a -> ('a * 'b) list -> ('a * 'b) list</code></pre><div class="info">
<code class="code">alist_delete</code> <i>key alist</i> deletes any entry labelled by value <i>key</i>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALalist_update"></a>alist_update : <code class="type">'a -> 'b -> ('a * 'b) list -> ('a * 'b) list</code></pre><div class="info">
<code class="code">alist_update</code> <i>key val alist</i> deletes <i>key</i> from <i>alist</i>, then cons
  on a <code class="code">(</code><i>key</i><code class="code">, </code><i>val</i><code class="code">)</code> entry.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALalist_compress"></a>alist_compress : <code class="type">('a * bool) list -> ('a * bool) list</code></pre><div class="info">
Compresses <i>alist</i> by removing shadowed entries. Example:
<pre><code class="code">  (* Shadowed (1 . c) entry removed. *)
    alist-compress [(1, a); (2, b); (1, c); (3, d)]    =&gt; [(1, a); (2, b); (3, d)]
</code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALwith_env"></a>with_env : <code class="type">(string * string) list -> (unit -> 'a) -> 'a</code></pre><pre><span class="keyword">val</span> <a name="VALwith_total_env"></a>with_total_env : <code class="type">(string * string) list -> (unit -> 'a) -> 'a</code></pre><div class="info">
These procedures call their last argument <i>thunk</i> in the context of an
 altered environment. They return whatever values <i>thunk</i> returns. Non-local
 returns restore the environment to its outer value.
<p>

In <code class="code">with_env</code> <i>env_alist_delta thunk</i>, the <i>env_alist_delta</i> argument
specifies a <em>modification</em> to the current environment --- <i>thunk</i>'s
environment is the original environment overridden with the bindings specified
by the alist delta.
<p>

In <code class="code">with_total_env</code> <i>env_alist thunk</i>, the <i>env_alist</i> argument specifies a
complete environment that is installed for <i>thunk</i>.<br>
</div>
<br>
Example: These three pieces of code all run the mailer with special <code class="code">$TERM</code>
and <code class="code">$EDITOR</code> values. 
<p>

<pre><code class="code">      let mail_me () = exec_path "mail" ["shivers@lcs.mit.edu"];; </code></pre>
<pre><code class="code">
      with_env ["TERM", "kterm"; "EDITOR", my_editor]
        (fun () -&gt; wait (fork_child mail_me));; </code></pre>
<pre><code class="code">
      wait
        (fork_child
           (* Env mutation happens in the subshell. *)
           (fun () -&gt;
              setenv ~sval:"kterm" "TERM";
              setenv ~sval:my_editor "EDITOR";
              mail_me ()));; </code></pre>
<pre><code class="code">
      (* In this example, we compute an alternate environment env2 as an alist, and
         install it with an explicit call to the exec_path_with_env procedure. *) 
      let env = alist_of_env () in       (* Get the current environment, *)
      let env1 = alist_update "TERM" "kterm" env in      (* and compute  *)
      let env2 = alist_update "EDITOR" my_editor env1 in (* the new env. *)
      wait
        (fork_child
           (fun () -&gt; exec_path_with_env "mail" ~env:env2 ["shivers@cs.cmu.edu"]));;
</code></pre><br><br>
<br>
<br>
<a name="3_Pathlistsandcolonlists"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Path lists and colon lists</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
When environment variables such as <code class="code">$PATH</code> need to encode a list of strings
(such as a list of directories to be searched), the common Unix convention is to
separate the list elements with colon delimiters (<i>...and hope the individual
list elements don't contain colons themselves.</i>)  To convert between the
colon-separated string encoding and the list-of-strings representation, see the
<code class="code">infix_splitter</code> function (section <a href="Cash.html#VALfield_splitter"><code class="code">field_splitter</code></a>) and the string
library's <code class="code">String.concat</code> function.  For example,
<pre><code class="code"> let split = infix_splitter ~delim:(Regexp (Pcre.regexp ":")) ();;
 split "/sbin:/bin::/usr/bin"                    =&gt; ["/sbin"; "/bin"; ""; "/usr/bin"]
 String.concat ":"  ["/sbin"; "/bin"; ""; "/usr/bin"]       =&gt; "/sbin:/bin::/usr/bin"
</code></pre>
<p>

The following two functions are useful for manipulating these ordered lists,
once they have been parsed from their colon-separated form.<br><br>
<pre><span class="keyword">val</span> <a name="VALadd_before"></a>add_before : <code class="type">'a -> 'a -> 'a list -> 'a list</code></pre><pre><span class="keyword">val</span> <a name="VALadd_after"></a>add_after : <code class="type">'a -> 'a -> 'a list -> 'a list</code></pre><div class="info">
These functions are for modifying search-path lists, where element order
 is significant. 
<p>

<code class="code">add_before</code> <i>elt before</i> adds <i>elt</i> to the list immediately before the
first occurrence of <i>before</i> in the list.  If <i>before</i> is not in the list,
<i>elt</i> is added to the end of the list.
<p>

<code class="code">add_after</code> <i>elt after</i> is similar: <i>elt</i> is added after the last occurrence
of <i>after</i>.  If <i>after</i> is not found, <i>elt</i> is added to the beginning of
the list.
<p>

The result may share structure with the original list.  Both functions use <code class="code">=</code>
for comparing elements.<br>
</div>
<br>
<br>
<a name="3_USERHOMEandPATH"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">$USER, $HOME, and $PATH</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Like sh and unlike csh, Cash has <em>no</em> interactive dependencies on
environment variables.  It does, however, initialise certain internal values at
startup time from the initial process environment, in particular <code class="code">$HOME</code> and
<code class="code">$PATH</code>.  Cash never uses <code class="code">$USER</code> at all.  It computes <code class="code">user_login_name ()</code> from
the system call <code class="code">user_uid ()</code>.<br><br>
<pre><span class="keyword">val</span> <a name="VALhome_directory"></a>home_directory : <code class="type">string Pervasives.ref</code></pre><div class="info">
Cash accesses <code class="code">$HOME</code> at start-up time, and stores the value in the
  global variable <code class="code">home_directory</code>. It uses this value for <code class="code">~</code> lookups and for
  returning to home on <code class="code">chdir ()</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALexec_path_list"></a>exec_path_list : <code class="type">unit -> string list</code></pre><pre><span class="keyword">val</span> <a name="VALset_exec_path_list"></a>set_exec_path_list : <code class="type">string list -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALwith_exec_path_list"></a>with_exec_path_list : <code class="type">string list -> (unit -> 'a) -> 'a</code></pre><div class="info">
Cash accesses <code class="code">$PATH</code> at start-up time, colon-splits the path list, and
  stores the value in an unexported variable, accessible by <code class="code">exec_path_list
  ()</code>. This list is used for <code class="code">exec_path</code> and <code class="code">exec_path_with_env</code> searches.  It
  can be permanently modified by <code class="code">set_exec_path_list</code> <i>new_list</i>, or for the
  duration of a call with <code class="code">with_exec_path_list</code> <i>new_list thunk</i> --- this is
  the recommended way to alter it.<br>
</div>
<br>
<br>
<a name="2_Terminaldevicecontrol"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Terminal device control</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Cash provides a complete set of routines for manipulating terminal devices
--- putting them in ``raw'' mode, changing and querying their special
characters, modifying their i/o speeds, and so forth.  The cash interface is
designed both for generality and portability across different Unix platforms, so
you don't have to rewrite your program each time you move to a new system.
We've also made an effort to use reasonable, Scheme-like names for the
multitudinous named constants involved, so when you are reading code, you'll
have less likelihood of getting lost in a bewildering maze of obfuscatory
constants named <code class="code">ICRNL</code>, <code class="code">INPCK</code>, <code class="code">IUCLC</code>, and <code class="code">ONOCR</code>.
<p>

This section can only lay out the basic functionality of the terminal device
interface.  For further details, see the termios(3) man page on your system, or
consult one of the standard Unix texts.<br><br>
<br>
<br>
<a name="3_PortabilityacrossOSvariants"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Portability across OS variants</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Terminal-control software is inescapably complex, ugly, and low-level.  Unix
variants each provide their own way of controlling terminal devices, making it
difficult to provide interfaces that are portable across different Unix systems.
Cash's terminal support is based primarily upon the Posix termios interface.
Programs that can be written using only the Posix interface are likely to be
widely portable.
<p>

The bulk of the documentation that follows consists of several pages worth of
tables defining different named constants that enable and disable different
features of the terminal driver.  Some of these flags are Posix; others are
taken from the two common branches of Unix development, SVR4 and 4.3+ Berkeley.
Cash guarantees that the non-Posix constants will be defined identifiers.<ul>
<li>If your OS supports a particular non-Posix flag, its named constant will be
  bound to the flag's value.</li>
<li>If your OS doesn't support the flag, its named constant will be present, but
  bound to -1.</li>
</ul>

This means that if you want to use SVR4 or Berkeley features in a program, your
program can portably test the values of the flags before using them --- the
flags can reliably be referenced without producing ``unbound value'' errors.
<p>

Finally, note that although Posix, SVR4, and Berkeley cover the lion's share of
the terminal-driver functionality, each operating system inevitably has
non-standard extensions.  While a particular cash implementation may provide
these extensions, they are not portable, and so are not documented here.<br><br>
<br>
<br>
<a name="3_Miscellaneousprocedures"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Miscellaneous procedures</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALis_tty_fd"></a>is_tty_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_tty_in"></a>is_tty_in : <code class="type">Pervasives.in_channel -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_tty_out"></a>is_tty_out : <code class="type">Pervasives.out_channel -> bool</code></pre><div class="info">
Return true if the argument is a tty.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtty_file_name_fd"></a>tty_file_name_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALtty_file_name_in"></a>tty_file_name_in : <code class="type">Pervasives.in_channel -> string</code></pre><pre><span class="keyword">val</span> <a name="VALtty_file_name_out"></a>tty_file_name_out : <code class="type">Pervasives.out_channel -> string</code></pre><div class="info">
The argument must be a file descriptor or channel open on a tty.
  Return the file-name of the tty.<br>
</div>
<br>
<br>
<a name="3_Thettyinforecordtype"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">The tty_info record type</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The primary data-structure that describes a terminal's mode is
a <code class="code">tty_info</code> record, defined as follows:<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEtty_info"></a>tty_info = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>control_chars&nbsp;: <code class="type">string</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Magic input chars</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>input_flags&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Input processing</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>output_flags&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Output processing</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>control_flags&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Serial-line control</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>local_flags&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Line-editting UI</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>input_speed&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Code for input speed</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>output_speed&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Code for output speed</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>min&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Raw-mode input policy</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>time&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Raw-mode input policy</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
<br>
<a name="4_Thecontrolcharactersstring"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title4"><td><div align=center>
<span class="title4">The control-characters string</span>
</div>
</td>
</tr>
</table>
<br>
</div>
<br>
<br>
The <code class="code">control_chars</code> field is a character string; its characters may be
indexed by integer values taken from the record <code class="code">ttychar</code>.<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEtty_chars"></a>tty_chars = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>delete_char&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: ERASE        typ. del</code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>delete_line&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: KILL         typ. ^U </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>eof&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: EOF          typ. ^D </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>eol&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: EOL                  </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>interrupt&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: INTR         typ. ^C </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>quit&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: QUIT         typ. ^\ </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>suspend&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: SUSP         typ. ^Z </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>start&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: START        typ. ^Q </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>stop&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: STOP         typ. ^S </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>delayed_suspend&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD    C: DSUSP        typ. ^Y </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>delete_word&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD    C: WERASE       typ. ^W </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>discard&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD    C: DISCARD      typ. ^O </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>eol2&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD    C: EOL2                 </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>literal_next&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD    C: LNEXT        typ. ^V </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>reprint&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> BSD         C: REPRINT      typ. ^R </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>status&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> BSD         C: STATUS       typ. ^T </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<br>
<pre><span class="keyword">val</span> <a name="VALttychar"></a>ttychar : <code class="type"><a href="Cash.html#TYPEtty_chars">tty_chars</a></code></pre><br>
As discussed above, only the Posix entries in <code class="code">ttychar</code> are guaranteed to be
legal, integer indices.  A program can reliably test the OS to see if the
non-Posix characters are supported by checking the index constants.  If the
control-character function is supported by the terminal driver, then the
corresponding index will be bound to a positive integer; if it is not supported,
the index will be bound to -1.<br><br>
<pre><span class="keyword">val</span> <a name="VALdisable_tty_char"></a>disable_tty_char : <code class="type">char</code></pre><div class="info">
To disable a given control-character function, set its corresponding entry
in the <code class="code">control_chars</code> string to the special character <code class="code">disable_tty_char</code> (and
then use a <code class="code">set_tty_info_...</code> procedure to update the terminal's state).<br>
</div>
<br>
<br>
<a name="4_Theflagfields"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title4"><td><div align=center>
<span class="title4">The flag fields</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The <code class="code">tty_info</code> record's <code class="code">input_flags</code>, <code class="code">output_flags</code>, <code class="code">control_flags</code>, and
<code class="code">local_flags</code> fields are all bit sets represented as two's-complement native
integers.  Their values are composed by or'ing together values taken from the
named constants in records <code class="code">ttyin</code>, <code class="code">ttyout</code> and <code class="code">ttyc</code>, described below.
<p>

As discussed above, only the Posix entries listed in these tables are guaranteed
to be legal, integer flag values.  A program can reliably test the OS to see if
the non-Posix flags are supported by checking the named constants.  If the
feature is supported by the terminal driver, then the corresponding flag will be
bound to an integer; if it is not supported, the flag will be bound to -1.<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEtty_in"></a>tty_in = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>check_parity&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: INPCK   Check Parity. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ignore_bad_parity_chars&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: IGNPAR  Ignore chars with parity errors. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>mark_parity_errors&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: PARMRK  Insert chars to mark parity errors. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ignore_break&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: IGNBRK  Ignore breaks. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>interrupt_on_break&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: BRKINT  Signal on breaks. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>seven_bits&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: ISTRIP  Strip char to seven bits. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>cr_to_nl&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: ICRNL   Map carriage-return to newline. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ignore_cr&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: IGNCR   Ignore carriage-returns. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nl_to_cr&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: INLCR   Map newline to carriage-return. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>input_flow_ctl&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: IXOFF   Enable input flow control. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>output_flow_ctl&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix       C: IXON    Enable output flow control. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>xon_any&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD    C: IXANY   Any char restarts after stop. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>beep_on_overflow&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD    C: IMAXBEL Ring bell when queue full. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>lowercase&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4        C: IUCLC   Map upper case to lower case. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<br>
<pre><span class="keyword">val</span> <a name="VALttyin"></a>ttyin : <code class="type"><a href="Cash.html#TYPEtty_in">tty_in</a></code></pre><div class="info">
These are the named flags for the <code class="code">tty_info</code> record's <i>input_flags</i> field.
  These flags generally control the processing of input chars.  Only the Posix
  entries are guaranteed to be &lt;&gt; -1.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEtty_out"></a>tty_out = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>enable&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: OPOST  Enable output processing. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nl_to_crnl&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: ONLCR  Map nl to cr-nl. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>discard_eot&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: ONOEOT Discard EOT chars. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>expand_tabs&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: OXTABS Expand tabs. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>cr_to_nl&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: OCRNL  Map cr to nl. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nl_does_cr&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: ONLRET Nl performs cr as well. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>no_col0_cr&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: ONOCR  No cr output in column 0. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>delay_with_fill_char&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: OFILL  Send fill char to delay. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>fill_with_del&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: OFDEL  Fill char is ASCII DEL. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>uppercase&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: OLCUC  Map lower to upper case. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>bs_delay&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Backspace delay: Bit-field mask </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>bs_delay0&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Backspace delay: values         </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>bs_delay1&nbsp;: <code class="type">nativeint</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>cr_delay&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Carriage-return delay: Bit-field mask </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>cr_delay0&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Carriage-return delay: values         </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>cr_delay1&nbsp;: <code class="type">nativeint</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>cr_delay2&nbsp;: <code class="type">nativeint</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>cr_delay3&nbsp;: <code class="type">nativeint</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ff_delay&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Form-feed delay: Bit-field mask </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ff_delay0&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Form-feed delay: values         </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ff_delay1&nbsp;: <code class="type">nativeint</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>tab_delay&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Horizontal-tab delay: Bit-field mask </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>tab_delay0&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Horizontal-tab delay: values         </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>tab_delay1&nbsp;: <code class="type">nativeint</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>tab_delay2&nbsp;: <code class="type">nativeint</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>tab_delayx&nbsp;: <code class="type">nativeint</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nl_delay&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Newline delay: Bit-field mask </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nl_delay0&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Newline delay: values         </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nl_delay1&nbsp;: <code class="type">nativeint</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>vtab_delay&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Vertical tab delay: Bit-field mask </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>vtab_delay0&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Vertical tab delay: values         </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>vtab_delay1&nbsp;: <code class="type">nativeint</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>all_delay&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> All: Total bit-field mask </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<br>
<pre><span class="keyword">val</span> <a name="VALttyout"></a>ttyout : <code class="type"><a href="Cash.html#TYPEtty_out">tty_out</a></code></pre><div class="info">
Output-flags (before bs_delay). These are the named flags for the <code class="code">tty_info</code>
  record's <i>output_flags</i> field.  These flags generally control the processing
  of output chars.  Only the Posix entries are guaranteed to be &lt;&gt; -1.
<p>

Then, delay constants. These are the named flags for the <code class="code">tty_info</code> record's <i>output_flags</i> field. These flags control the output delays associated with
printing special characters.  They are non-Posix, and have values &lt;&gt; -1 only on
SVR4 systems.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEtty_c"></a>tty_c = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>char_size&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: CSIZE      Character size mask </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>char_size5&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: CS5        5 bits. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>char_size6&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: CS6        6 bits. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>char_size7&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: CS7        7 bits. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>char_size8&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: CS8        8 bits. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>enable_parity&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: PARENB     Generate and detect parity. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>odd_parity&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: PARODD     Odd parity. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>enable_read&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: CREAD      Enable reception of chars. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>hup_on_close&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: HUPCL      Hang up on last close. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>no_modem_sync&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: LOCAL      Ignore modem lines. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>two_stop_bits&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: CSTOPB     Send two stop bits. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ignore_flags&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix    C: CIGNORE    Ignore control flags. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>cts_output_flow_control&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> BSD      C: CCTS_OFLOW CTS flow control of output. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>rts_input_flow_control&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> BSD      C: CRTS_IFLOW RTS flow control of output. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>carrier_flow_ctl&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> BSD      C: MDMBUF      </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<br>
<pre><span class="keyword">val</span> <a name="VALttyc"></a>ttyc : <code class="type"><a href="Cash.html#TYPEtty_c">tty_c</a></code></pre><div class="info">
Control-flags.  These are the named flags for the <code class="code">tty_info</code> record's <i>  control_flags</i> field.  These flags generally control the details of the
  terminal's serial line.  Only the Posix entries are guaranteed to be &lt;&gt; -1.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEtty_l"></a>tty_l = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>canonical&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix        C: ICANON     Canonical input processing. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>echo&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix        C: ECHO       Enable echoing. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>echo_delete_lines&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix        C: ECHOK      Echo newline after line kill. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>echo_nl&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix        C: ECHONL     Echo newline even if echo is off. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>visual_delete&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix        C: ECHOE      Visually erase chars. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>enable_signals&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix        C: ISIG       Enable ^C, ^Z signalling. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>extended&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix        C: IEXTEN     Enable extensions. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>no_flush_on_interrupt&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix        C: NOFLSH     Don't flush after interrupt. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>ttou_signal&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> Posix        C: TOSTOP     SIGTTOU on background output. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>echo_ctl&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD     C: ECHOCTL    Echo control chars as "^X". </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>flush_output&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD     C: FLUSHO     Output is being flushed. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>hardcopy_delete&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD     C: ECHOPRT    Visual erase for hardcopy. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>reprint_unread_chars&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD     C: PENDIN     Retype pending input. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>visual_delete_line&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4+BSD     C: ECHOKE     Visually erase a line-kill. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>alt_delete_word&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> BSD          C: ALTWERASE  Alternate word erase algorithm. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>no_kernel_status&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> BSD          C: NOKERNINFO No kernel status on ^T. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>case_map&nbsp;: <code class="type">nativeint</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code><pre><code class="code"> SVR4         C: XCASE      Canonical case presentation. </code></pre></code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<br>
<pre><span class="keyword">val</span> <a name="VALttyl"></a>ttyl : <code class="type"><a href="Cash.html#TYPEtty_l">tty_l</a></code></pre><div class="info">
Local-flags.  These are the named flags for the <code class="code">tty_info</code> record's <i>local_flags</i> field.  These flags generally control the details of the
line-editing user interface.  Only the Posix entries are guaranteed to be &lt;&gt; -1.<br>
</div>
<br>
<br>
<a name="4_Thespeedfields"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title4"><td><div align=center>
<span class="title4">The speed fields</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The <code class="code">input_speed</code> and <code class="code">output_speed</code> fields determine the I/O rate of the
terminal's line.  The value of these fields is an integer giving the speed in
bits-per-second.  The following speeds are supported by Posix:
<pre>                  0     134      600     4800 
                 50     150     1200     9600 
                 75     200     1800    19200
                110     300     2400    38400</pre>
<p>

Your OS may accept others; there's currently no provision for the special values
<code class="code">EXTA</code> and <code class="code">EXTB</code>.<br><br>
<br>
<br>
<a name="4_Theminandtimefields"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title4"><td><div align=center>
<span class="title4">The min and time fields</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The integer <code class="code">min</code> and <code class="code">time</code> fields determine input blocking behaviour
during non-canonical (raw) input; otherwise, they are ignored.  See the
termios(3) man page for further details.
<p>

Be warned that Posix allows the base system call's representation of the
<code class="code">tty_info</code> record to share storage for the <code class="code">min</code> field and the <code class="code">ttychar.eof</code>
element of the control-characters string, and for the <code class="code">time</code> field and the
<code class="code">ttychar/eol</code> element of the control-characters string.  Many implementations in
fact do this.
<p>

To stay out of trouble, set the <code class="code">min</code> and <code class="code">time</code> fields only if you are putting
the terminal into raw mode; set the eof and eol control-characters only if you
are putting the terminal into canonical mode.  It's ugly, but it's Unix.<br><br>
<br>
<br>
<a name="4_Usingttyinforecords"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title4"><td><div align=center>
<span class="title4">Using tty-info records</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALmake_tty_info"></a>make_tty_info : <code class="type">nativeint -><br>       nativeint -><br>       nativeint -> nativeint -> int -> int -> int -> int -> <a href="Cash.html#TYPEtty_info">tty_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALcopy_tty_info"></a>copy_tty_info : <code class="type"><a href="Cash.html#TYPEtty_info">tty_info</a> -> <a href="Cash.html#TYPEtty_info">tty_info</a></code></pre><div class="info">
These procedures make it possible to create new <code class="code">tty_info</code> records.
  The typical method for creating a new record is to copy one retrieved by a
  call to the <code class="code">tty_info</code> procedure, then modify the copy as desired.  Note that
  the call <code class="code">make_tty_info</code> <i>input_flags output_flags control_flags local_flags
  ispeed ospeed min time</i> does not take a parameter to define the new record's
  control characters.
<p>

<i>Why? Because the length of the string varies from Unix to Unix.  For example,
the word-erase control character (typically control-w) is provided by most
Unixes, but not part of the Posix spec.</i>  Instead, it simply returns a
<code class="code">tty_info</code> record whose control-character string has all elements initialised to
ASCII nul.  You may then install the special characters by assigning to the
string.  Similarly, the control-character string in the record produced by
<code class="code">copy_tty_info</code> does not share structure with the string in the record being
copied, so you may mutate it freely.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtty_info_fd"></a>tty_info_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEtty_info">tty_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALtty_info_in"></a>tty_info_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEtty_info">tty_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALtty_info_out"></a>tty_info_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEtty_info">tty_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALtty_info_fn"></a>tty_info_fn : <code class="type">string -> <a href="Cash.html#TYPEtty_info">tty_info</a></code></pre><div class="info">
The <i>fd/channel/string</i> parameter is an integer file descriptor, Caml
channel opened on a terminal device, or a file-name for a terminal device.  This
procedure returns a <code class="code">tty_info</code> record describing the terminal's current mode.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_tty_info_now_fd"></a>set_tty_info_now_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_info_now_in"></a>set_tty_info_now_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_info_now_out"></a>set_tty_info_now_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_info_now_fn"></a>set_tty_info_now_fn : <code class="type">string -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_info_drain_fd"></a>set_tty_info_drain_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_info_drain_in"></a>set_tty_info_drain_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_info_drain_out"></a>set_tty_info_drain_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_info_drain_fn"></a>set_tty_info_drain_fn : <code class="type">string -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_info_flush_fd"></a>set_tty_info_flush_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_info_flush_in"></a>set_tty_info_flush_in : <code class="type">Pervasives.in_channel -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_info_flush_out"></a>set_tty_info_flush_out : <code class="type">Pervasives.out_channel -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_info_flush_fn"></a>set_tty_info_flush_fn : <code class="type">string -> <a href="Cash.html#TYPEtty_info">tty_info</a> -> unit</code></pre><div class="info">
The <i>fd/channel/string</i> parameter is an integer file descriptor or Caml
channel opened on a terminal device, or a file-name for a terminal device.  The
The procedure chosen determines when and how the terminal's mode is altered:
<pre>   set_tty_info_now_...         Make change immediately.
   set_tty_info_drain_...       Drain output, then change.
   set_tty_info_flush_...       Drain output, flush input, then change.</pre><br>
</div>
<br>
<br>
<a name="3_Otherterminaldeviceprocedures"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Other terminal-device procedures</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALsend_tty_break_fd"></a>send_tty_break_fd : <code class="type">?duration:int -> <a href="Cash.html#TYPEfd">fd</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsend_tty_break_in"></a>send_tty_break_in : <code class="type">?duration:int -> Pervasives.in_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsend_tty_break_out"></a>send_tty_break_out : <code class="type">?duration:int -> Pervasives.out_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsend_tty_break_fn"></a>send_tty_break_fn : <code class="type">?duration:int -> string -> unit</code></pre><div class="info">
The <i>fd/channel/string</i> parameter is an integer file descriptor or Caml
  channel opened on a terminal device, or a file-name for a terminal device.
Send a break signal to the designated terminal.  A break signal is a sequence of
continuous zeros on the terminal's transmission line.
<p>

The <i>duration</i> argument determines the length of the break signal.  A zero
value (the default) causes a break of between 0.25 and 0.5 seconds to be sent;
other values determine a period in a manner that will depend upon local
community standards.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdrain_tty_fd"></a>drain_tty_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALdrain_tty_in"></a>drain_tty_in : <code class="type">Pervasives.in_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALdrain_tty_out"></a>drain_tty_out : <code class="type">Pervasives.out_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALdrain_tty_fn"></a>drain_tty_fn : <code class="type">string -> unit</code></pre><div class="info">
The <i>fd/channel/string</i> parameter is an integer file descriptor or Caml
channel opened on a terminal device, or a file-name for a terminal device.
<p>

This procedure waits until all the output written to the terminal device has
been transmitted to the device.  If <i>channel</i> is an out_channel with buffered
I/O enabled, then the port's buffered characters are flushed before waiting for
the device to drain.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALflush_tty_input_fd"></a>flush_tty_input_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALflush_tty_input_in"></a>flush_tty_input_in : <code class="type">Pervasives.in_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALflush_tty_input_out"></a>flush_tty_input_out : <code class="type">Pervasives.out_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALflush_tty_input_fn"></a>flush_tty_input_fn : <code class="type">string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALflush_tty_output_fd"></a>flush_tty_output_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALflush_tty_output_in"></a>flush_tty_output_in : <code class="type">Pervasives.in_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALflush_tty_output_out"></a>flush_tty_output_out : <code class="type">Pervasives.out_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALflush_tty_output_fn"></a>flush_tty_output_fn : <code class="type">string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALflush_tty_both_fd"></a>flush_tty_both_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALflush_tty_both_in"></a>flush_tty_both_in : <code class="type">Pervasives.in_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALflush_tty_both_out"></a>flush_tty_both_out : <code class="type">Pervasives.out_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALflush_tty_both_fn"></a>flush_tty_both_fn : <code class="type">string -> unit</code></pre><div class="info">
The <i>fd/channel/string</i> parameter is an integer file descriptor or Caml
   channel opened on a terminal device, or a file-name for a terminal device.
<p>

These procedures discard the unread input chars or unwritten output chars in the
tty's kernel buffers.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstart_tty_output_fd"></a>start_tty_output_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstart_tty_output_in"></a>start_tty_output_in : <code class="type">Pervasives.in_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstart_tty_output_out"></a>start_tty_output_out : <code class="type">Pervasives.out_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstart_tty_output_fn"></a>start_tty_output_fn : <code class="type">string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstop_tty_output_fd"></a>stop_tty_output_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstop_tty_output_in"></a>stop_tty_output_in : <code class="type">Pervasives.in_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstop_tty_output_out"></a>stop_tty_output_out : <code class="type">Pervasives.out_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstop_tty_output_fn"></a>stop_tty_output_fn : <code class="type">string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstart_tty_input_fd"></a>start_tty_input_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstart_tty_input_in"></a>start_tty_input_in : <code class="type">Pervasives.in_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstart_tty_input_out"></a>start_tty_input_out : <code class="type">Pervasives.out_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstart_tty_input_fn"></a>start_tty_input_fn : <code class="type">string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstop_tty_input_fd"></a>stop_tty_input_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstop_tty_input_in"></a>stop_tty_input_in : <code class="type">Pervasives.in_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstop_tty_input_out"></a>stop_tty_input_out : <code class="type">Pervasives.out_channel -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALstop_tty_input_fn"></a>stop_tty_input_fn : <code class="type">string -> unit</code></pre><div class="info">
These procedures can be used to control a terminal's input and output flow.
The <i>fd/channel/string</i> parameter is an integer file descriptor or Caml
channel opened on a terminal device, or a file-name for a terminal device.
<p>

The <code class="code">stop_tty_output_...</code> and <code class="code">start_tty_output_...</code> procedures suspend and
resume output from a terminal device.  The <code class="code">stop_tty_input_...</code> and
<code class="code">start_tty_input_...</code> procedures transmit the special STOP and START characters
to the terminal with the intention of stopping and starting terminal input flow.<br>
</div>
<br>
<br>
<a name="3_Controlterminalssessionsandterminalprocessgroups"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Control terminals, sessions, and terminal process groups</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALopen_control_tty_in"></a>open_control_tty_in : <code class="type">?flags:Io_3_2.open_flag list -> string -> Pervasives.in_channel</code></pre><pre><span class="keyword">val</span> <a name="VALopen_control_tty_out"></a>open_control_tty_out : <code class="type">?flags:Io_3_2.open_flag list -> string -> Pervasives.out_channel</code></pre><div class="info">
This procedure opens terminal device <i>tty_name</i> as the process' control
terminal (see the <code class="code">termios</code> man page for more information on control terminals).
The <i>tty_name</i> argument is a file-name such as <code class="code">/dev/ttya</code>.  The <i>flags</i>
argument is a value suitable as the last argument to the <code class="code">open_file</code> call; it
defaults to <code class="code">O_RDWR</code> for <code class="code">open_control_tty_in</code>, causing the terminal to be
opened for both input and output, and <code class="code">O_WRONLY</code> for <code class="code">open_control_tty_out</code>.
<p>

The channel returned is an in_channel if the <i>flags</i> permit it, otherwise an
out_channel.  Ocaml do not have input/output channels, so it's one or the other.
However, you can get both read and write channels open on a terminal by opening
it read/write with <code class="code">open_control_tty_in</code>, taking the result in_channel, and
duping it to an output channel with <code class="code">out_channel_of_dup_in</code>.
<p>

This procedure guarantees to make the opened terminal the process' control
terminal only if the process does not have an assigned control terminal at the
time of the call.  If the scsh process already has a control terminal, the
results are undefined.
<p>

To arrange for the process to have no control terminal prior to calling this
procedure, use the <code class="code">become_session_leader</code> procedure.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbecome_session_leader"></a>become_session_leader : <code class="type">unit -> int</code></pre><div class="info">
This is the C <code class="code">setsid()</code> call.  Posix job-control has a three-level
hierarchy: session/process-group/process.  Every session has an associated
control terminal.  This procedure places the current process into a brand new
session, and disassociates the process from any previous control terminal.  You
may subsequently use <code class="code">open_control_tty</code> to open a new control terminal.
<p>

It is an error to call this procedure if the current process is already a
process-group leader.  One way to guarantee this is not the case is only to call
this procedure after forking.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtty_process_group_fd"></a>tty_process_group_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALtty_process_group_in"></a>tty_process_group_in : <code class="type">Pervasives.in_channel -> int</code></pre><pre><span class="keyword">val</span> <a name="VALtty_process_group_out"></a>tty_process_group_out : <code class="type">Pervasives.out_channel -> int</code></pre><pre><span class="keyword">val</span> <a name="VALtty_process_group_fn"></a>tty_process_group_fn : <code class="type">string -> int</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_process_group_fd"></a>set_tty_process_group_fd : <code class="type"><a href="Cash.html#TYPEfd">fd</a> -> int -> int</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_process_group_in"></a>set_tty_process_group_in : <code class="type">Pervasives.in_channel -> int -> int</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_process_group_out"></a>set_tty_process_group_out : <code class="type">Pervasives.out_channel -> int -> int</code></pre><pre><span class="keyword">val</span> <a name="VALset_tty_process_group_fn"></a>set_tty_process_group_fn : <code class="type">string -> int -> int</code></pre><div class="info">
These eight procedures get and set the process group of a given terminal.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcontrol_tty_file_name"></a>control_tty_file_name : <code class="type">unit -> string</code></pre><div class="info">
Return the file-name of the process' control tty.  On every version of Unix
of which we are aware, this is just the string <code class="code">"/dev/tty"</code>.  However, this
procedure uses the official Posix interface, so it is more portable than simply
using a constant string.<br>
</div>
<br>
<br>
<a name="3_Pseudoterminals"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Pseudo-terminals</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Cash implements an interface to Berkeley-style pseudo-terminals.<br><br>
<pre><span class="keyword">val</span> <a name="VALfork_pty_session"></a>fork_pty_session : <code class="type">(unit -> unit) -><br>       Proc_3_4.proc * Pervasives.in_channel * Pervasives.out_channel * string</code></pre><div class="info">
<code class="code">fork_pty_session</code> <i>thunk</i> gives a convenient high-level interface to
pseudo-terminals.  It first allocates a pty/tty pair of devices, and then forks
a child to execute procedure <i>thunk</i>.  In the child process<ul>
<li>Stdio and the current I/O channels are bound to the terminal device.</li>
<li>The child is placed in its own, new session (see <code class="code">become_session_leader</code>).</li>
<li>The terminal device becomes the new session's controlling terminal (see
  <code class="code">open_control_tty</code>).</li>
<li><code class="code">stderr</code> is unbuffered.</li>
</ul>

The <code class="code">fork_pty_session</code> procedure returns four values: the child's process
object, two channels open on the controlling pty device, and the name of the
child's corresponding terminal device.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALopen_pty"></a>open_pty : <code class="type">unit -> Pervasives.in_channel * string</code></pre><div class="info">
This procedure finds a free pty/tty pair, and opens the pty device with
read/write access.  It returns a channel on the pty, and the name of the
corresponding terminal device.
<p>

The channel returned is an input channel -- Caml doesn't allow input/output
channels.  However, you can easily use <code class="code">out_channel_of_dup_in</code> <i>pty_in_channel</i> to produce a matching output channel.  You may wish to turn off
I/O buffering for this output channel.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtty_name_of_pty_name"></a>tty_name_of_pty_name : <code class="type">string -> string</code></pre><pre><span class="keyword">val</span> <a name="VALpty_name_of_tty_name"></a>pty_name_of_tty_name : <code class="type">string -> string</code></pre><div class="info">
These two procedures map between corresponding terminal and pty controller
names. For example,
<pre><code class="code">   tty_name_of_pty_name "/dev/ptyq3"          =&gt; "/dev/ttyq3"
   pty_name_of_tty_name "/dev/ttyrc"          =&gt; "/dev/ptyrc"
</code></pre>
<p>

<i>This is rather Berkeley-specific. SVR4 ptys are rare enough that I (Olin)
have no real idea if it generalises across the Unix gap. Experts are invited to
advise. Users feel free to not worry -- the predominance of current popular Unix
systems use Berkeley ptys. </i><br>
</div>
<pre><span class="keyword">val</span> <a name="VALmake_pty_generator"></a>make_pty_generator : <code class="type">unit -> unit -> string</code></pre><div class="info">
<code class="code">make_pty_generator ()</code> returns a generator of candidate pty names.  Each
time the returned procedure is called, it produces a new candidate.  Software
that wishes to search through the set of available ptys can use a pty generator
to iterate over them.  After producing all the possible ptys, a generator
raises <code class="code">Not_found</code> every time it is called.  Example:
<pre><code class="code">
   let pg = make_pty_generator ();
   pg ();                       =&gt; "/dev/ptyp0"
   pg ();                       =&gt; "/dev/ptyp1"
...
   pg ();                       =&gt; "/dev/ptyqe"
   pg ();                       =&gt; "/dev/ptyqf"
   pg ();                       =&gt; Not_found
   pg ();                       =&gt; Not_found
...
</code></pre><br>
</div>
<br>
<br>
<a name="1_Networking"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title1"><td><div align=center>
<span class="title1">Networking</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The Caml Shell provides a BSD-style sockets interface.  There is not an
official standard for a network interface for Cash to adopt (this is the subject
of the forthcoming Posix.8 standard).  However, Berkeley sockets are a <i>de
facto</i> standard, being found on most Unix workstations and PC operating systems.
<p>

It is fairly straightforward to add higher-level network protocols such as smtp,
telnet, or http on top of the the basic socket-level support Cash provides.  For
those who read scheme, the Scheme Underground has also released a network
library with many of these protocols as a companion to the current release of
Scsh.  See this code for examples showing the use of the sockets interface.<br><br>
<br>
<br>
<a name="2_Sockets"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Sockets</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
A socket is one end of a network connection. Three specific properties of
sockets are specified at creation time: the protocol-family, type, and
protocol.<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEsocket_domain"></a>socket_domain = <code class="type">Unix.socket_domain</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PF_UNIX</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">PF_INET</span></code></td>

</tr></table>

<br>
<br><code><span class="keyword">type</span> <a name="TYPEprotocol_family"></a>protocol_family = <code class="type"><a href="Cash.html#TYPEsocket_domain">socket_domain</a></code> </code>
<div class="info">
The <code class="code">protocol_family</code> specifies the protocol family to be used with the
socket. This also determines the address family of socket addresses, which are
described in more detail below.  It is the same type as <code class="code">Unix.socket_domain</code>.<br>
</div>
<br>
<br><code><span class="keyword">type</span> <a name="TYPEsocket_type"></a>socket_type = <code class="type">Unix.socket_type</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SOCK_STREAM</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SOCK_DGRAM</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SOCK_RAW</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SOCK_SEQPACKET</span></code></td>

</tr></table>

<div class="info">
The <code class="code">socket_type</code> specifies the style of communication. Examples that your
operating system probably provides are stream and datagram sockets.  Others
maybe available depending on your system. Cash supports the same values as
<code class="code">Unix.socket_type</code>.<br>
</div>
<br>
<br><code><span class="keyword">type</span> <a name="TYPEprotocol_level"></a>protocol_level = <code class="type">Network_4.protocol_level</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SOL_SOCKET</span></code></td>

</tr></table>

<div class="info">
The <i>protocol</i> specifies a particular protocol to use within a protocol
family and type. Usually only one choice exists, but it's probably safest to set
this explicitly. See the protocol database routines for information on looking
up protocol constants.<br>
</div>
<br>
<br><code><span class="keyword">type</span> <a name="TYPEsocket"></a>socket = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>family&nbsp;: <code class="type"><a href="Cash.html#TYPEprotocol_family">protocol_family</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>sock_in&nbsp;: <code class="type">Pervasives.in_channel</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>sock_out&nbsp;: <code class="type">Pervasives.out_channel</code>;</code></td>

</tr></table>
}

<div class="info">
Type of the sockets.
<p>

The <code class="code">family</code> specifies the protocol family of the socket. The <code class="code">sock_in</code> and
<code class="code">sock_out</code> fields are channels that can be used for input and output,
respectively. For a stream socket, they are only usable after a connection has
been established via <a href="Cash.html#VALconnect_socket"><code class="code">connect_socket</code></a> or <a href="Cash.html#VALaccept_connection"><code class="code">accept_connection</code></a>. For a
datagram socket, a socket can be immediately used by <a href="Cash.html#VALsend_message"><code class="code">send_message</code></a>, and
<i>sock_in</i> can be used after <a href="Cash.html#VALbind_socket"><code class="code">bind_socket</code></a> has created a local
address.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALcreate_socket"></a>create_socket : <code class="type">?protocol:int -> <a href="Cash.html#TYPEprotocol_family">protocol_family</a> -> <a href="Cash.html#TYPEsocket_type">socket_type</a> -> <a href="Cash.html#TYPEsocket">socket</a></code></pre><pre><span class="keyword">val</span> <a name="VALcreate_socket_pair"></a>create_socket_pair : <code class="type"><a href="Cash.html#TYPEsocket_type">socket_type</a> -> <a href="Cash.html#TYPEsocket">socket</a> * <a href="Cash.html#TYPEsocket">socket</a></code></pre><div class="info">
New sockets are typically created with <code class="code">create_socket</code>.  However,
<code class="code">create_socket_pair</code> can also be used to create a pair of connected sockets in
the <code class="code">PF_UNIX</code> protocol-family.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALclose_socket"></a>close_socket : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> unit</code></pre><div class="info">
<code class="code">close_socket</code> provides a convenient way to close a socket's channel. It is
preferred to explicitly closing the sock_in and sock_out because using
<code class="code">close_in</code> or <code class="code">close_out</code> on sockets is not currently portable across operating
systems.<br>
</div>
<br>
<br>
<a name="2_Socketaddresses"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Socket addresses</span>
</div>
</td>
</tr>
</table>
<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEinet_addr"></a>inet_addr = <code class="type">Unix.inet_addr</code> </code>
<div class="info">
The type of Internet hosts addresses. Besides being an opaque host address,
an Internet host address can also be one of the following constants:<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALinet_addr_any"></a>inet_addr_any : <code class="type"><a href="Cash.html#TYPEinet_addr">inet_addr</a></code></pre><pre><span class="keyword">val</span> <a name="VALinet_addr_loopback"></a>inet_addr_loopback : <code class="type"><a href="Cash.html#TYPEinet_addr">inet_addr</a></code></pre><pre><span class="keyword">val</span> <a name="VALinet_addr_broadcast"></a>inet_addr_broadcast : <code class="type"><a href="Cash.html#TYPEinet_addr">inet_addr</a></code></pre><div class="info">
The use of <code class="code">inet_addr_any</code> is described below in <a href="Cash.html#VALbind_socket"><code class="code">bind_socket</code></a>.
<code class="code">inet_addr_loopback</code> is an address that always specifies the local
machine. <code class="code">inet_addr_broadcast</code> is used for network broadcast communications.
<p>

For information on obtaining a host's address, see the <a href="Cash.html#VALhost_info_name"><code class="code">host_info_name</code></a>
and <a href="Cash.html#VALhost_info_addr"><code class="code">host_info_addr</code></a> functions below.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEsockaddr"></a>sockaddr = <code class="type">Unix.sockaddr</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ADDR_UNIX</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">ADDR_INET</span> <span class="keyword">of</span> <code class="type"><a href="Cash.html#TYPEinet_addr">inet_addr</a> * int</code></code></td>

</tr></table>

<div class="info">
The format of a socket-address depends on the address family of the
socket. Address-family-specific routines are provided to convert
protocol-specific addresses to socket addresses. The value returned by
these routines has type sockaddr (an alias of <code class="code">Unix.sockaddr</code>).<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALsocket_address_of_unix_address"></a>socket_address_of_unix_address : <code class="type">string -> <a href="Cash.html#TYPEsockaddr">sockaddr</a></code></pre><div class="info">
<code class="code">socket_address_of_unix_address</code> <i>pathname</i> returns a <i>socket-address</i>
based on the string <i>pathname</i>. There is a system dependent limit on the
length of <i>pathname</i>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsocket_address_of_internet_address"></a>socket_address_of_internet_address : <code class="type"><a href="Cash.html#TYPEinet_addr">inet_addr</a> -> int -> <a href="Cash.html#TYPEsockaddr">sockaddr</a></code></pre><div class="info">
<code class="code">socket_address_of_internet_address</code> <i>host_address service_port</i> returns a
<i>socket_address</i> based on an <i>host_address</i> and an integer <i>service_port</i>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsockaddr_of_host_and_port"></a>sockaddr_of_host_and_port : <code class="type">string -> int -> <a href="Cash.html#TYPEsockaddr">sockaddr</a></code></pre><pre><span class="keyword">val</span> <a name="VALsockaddr_of_host_and_service"></a>sockaddr_of_host_and_service : <code class="type">string -> string -> <a href="Cash.html#TYPEsockaddr">sockaddr</a></code></pre><div class="info">
At a slightly higher level of interface, you can also give an host name and
  a port number (or service name) to one of these two procedures, which
  resolve the given name(s) to make an Internet socket address.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALunix_address_of_socket_address"></a>unix_address_of_socket_address : <code class="type"><a href="Cash.html#TYPEsockaddr">sockaddr</a> -> string</code></pre><pre><span class="keyword">val</span> <a name="VALinternet_address_of_socket_address"></a>internet_address_of_socket_address : <code class="type"><a href="Cash.html#TYPEsockaddr">sockaddr</a> -> <a href="Cash.html#TYPEinet_addr">inet_addr</a> * int</code></pre><div class="info">
These routines return the address-family-specific addresses.  Be aware that
most implementations don't correctly return anything more than an empty string
for addresses in the <code class="code">ADDR_UNIX</code> address-family.<br>
</div>
<br>
<br>
<a name="2_Highlevelinterface"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">High-level interface</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
For convenience, and to avoid some of the messy details of the socket
interface, we provide a high level socket interface. These routines attempt to
make it easy to write simple clients and servers without having to think of many
of the details of initiating socket connections.  We welcome suggested
improvements to this interface, including better names, which right now are
solely descriptions of the procedure's action.  This might be fine for people
who already understand sockets, but does not help the new networking
programmer.<br><br>
<pre><span class="keyword">val</span> <a name="VALsocket_connect"></a>socket_connect : <code class="type"><a href="Cash.html#TYPEsockaddr">sockaddr</a> -> <a href="Cash.html#TYPEsocket_type">socket_type</a> -> unit</code></pre><div class="info">
<code class="code">socket_connect</code> <i>socket_address socket_type</i> is intended for creating
client applications.  <code class="code">socket_connect</code> returns a <code class="code">socket</code> which can be used for
input and output from a remote server.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbind_listen_accept_loop_unix"></a>bind_listen_accept_loop_unix : <code class="type">string -> (<a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEsockaddr">sockaddr</a> -> unit) -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALbind_listen_accept_loop_port"></a>bind_listen_accept_loop_port : <code class="type">int -> (<a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEsockaddr">sockaddr</a> -> unit) -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALbind_listen_accept_loop_service"></a>bind_listen_accept_loop_service : <code class="type">string -> (<a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEsockaddr">sockaddr</a> -> unit) -> unit</code></pre><br>
<code class="code">bind_listen_accept_loop_...</code> <i>what proc</i> is intended for creating server
applications. <i>what</i> tells what to connect to.  <i>proc</i> is a procedure whose
arguments: a <code class="code">socket</code> and a <code class="code">sockaddr</code>, are made from <i>what</i>.
<p>

<code class="code">bind_listen_accept_loop_unix</code> <i>path</i> uses a path to make the <code class="code">socket</code> in the
<code class="code">PF_UNIX</code> protocol-family.
<p>

<code class="code">bind_listen_accept_loop_port</code> <i>port</i> makes the <code class="code">socket</code> in the <code class="code">PF_INET</code>
protocol-family.  You may use a service name instead with
<code class="code">bind_listen_accept_loop_service</code> <i>service</i>.
<p>

<i>proc</i> is called with a socket and a socket address each time there is a
connection from a client application. The socket allows communications with the
client.  The socket address specifies the address of the remote client.
<p>

This procedure does not return, but loops indefinitely accepting connections
from client programs.<br><br>
<br>
<br>
<a name="2_Socketprimitives"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Socket primitives</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The procedures in this section are presented in the order in which a
typical program will use them. Consult a text on network systems
programming for more information on sockets.
Some recommended ones are:<ul>
<li>``Unix Network Programming'' by W. Richard Stevens</li>
<li>``An Introductory 4.3BSD Interprocess Communication Tutorial.''  (reprinted in
  UNIX Programmer's Supplementary Documents Volume 1, PS1:7)</li>
<li>``An Advanced 4.3BSD Interprocess Communication Tutorial.''  (reprinted in
  UNIX Programmer's Supplementary Documents Volume 1, PS1:8)</li>
</ul>

The last two tutorials are freely available as part of BSD. In the absence of
these, your Unix manual pages for socket might be a good starting point for
information.<br><br>
<pre><span class="keyword">val</span> <a name="VALconnect_socket"></a>connect_socket : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEsockaddr">sockaddr</a> -> unit</code></pre><div class="info">
<code class="code">connect_socket</code> <i>socket socket-address</i> sets up a connection from a <i>socket</i> to a remote <i>socket-address</i>. A connection has different meanings
depending on the socket type. A stream socket must be connected before use. A
datagram socket can be connected multiple times, but need not be connected at
all if the remote address is specified with each <code class="code">send_message</code>, described
below. Also, datagram sockets may be disassociated from a remote address by
connecting to a null remote address.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbind_socket"></a>bind_socket : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEsockaddr">sockaddr</a> -> unit</code></pre><div class="info">
<code class="code">bind_socket</code> <i>socket socket-address</i> assigns a certain local <i>socket-address</i> to a <i>socket</i>. Binding a socket reserves the local address. To
receive connections after binding the socket, use <code class="code">listen_socket</code> for stream
sockets and <code class="code">receive_message</code> for datagram sockets.
<p>

Binding an Internet socket with a host address of <code class="code">inet_addr_any</code> indicates that
the caller does not care to specify from which local network interface
connections are received. Binding an Internet socket with a service port number
of zero indicates that the caller has no preference as to the port number
assigned.
<p>

Binding a socket in the Unix address family creates a socket special file in the
file system that must be deleted before the address can be reused. See
<code class="code">delete_file</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlisten_socket"></a>listen_socket : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> int -> unit</code></pre><div class="info">
<code class="code">listen_socket</code> <i>socket backlog</i> allows a stream <i>socket</i> to start
receiving connections, allowing a queue of up to <i>backlog</i> connection
requests. Queued connections may be accepted by <code class="code">accept_connection</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALaccept_connection"></a>accept_connection : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEsocket">socket</a> * <a href="Cash.html#TYPEsockaddr">sockaddr</a></code></pre><div class="info">
<code class="code">accept_connection</code> receives a connection on a <i>socket</i>, returning
a new socket that can be used for this connection and the remote socket
address associated with the connection.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsocket_local_address"></a>socket_local_address : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEsockaddr">sockaddr</a></code></pre><pre><span class="keyword">val</span> <a name="VALsocket_remote_address"></a>socket_remote_address : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEsockaddr">sockaddr</a></code></pre><div class="info">
Sockets can be associated with a local address or a remote address or
both. <code class="code">socket_local_address</code> returns the local <i>sockaddr</i> record associated
with <i>socket</i>. <code class="code">socket_remote_address</code> returns the remote <i>sockaddr</i> record
associated with <i>socket</i>.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEshutdown_command"></a>shutdown_command = <code class="type">Unix.shutdown_command</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SHUTDOWN_RECEIVE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SHUTDOWN_SEND</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SHUTDOWN_ALL</span></code></td>

</tr></table>

<br>
<pre><span class="keyword">val</span> <a name="VALshutdown_socket"></a>shutdown_socket : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEshutdown_command">shutdown_command</a> -> unit</code></pre><div class="info">
<code class="code">shutdown_socket</code> <i>how_to</i> shuts down part of a full-duplex socket.  The
part to shut down is specified by the <i>how_to</i> argument.<br>
</div>
<br>
<br>
<a name="2_Performinginputandoutputonsockets"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Performing input and output on sockets</span>
</div>
</td>
</tr>
</table>
<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEmsg_flag"></a>msg_flag = <code class="type">Unix.msg_flag</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">MSG_OOB</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">MSG_DONTROUTE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">MSG_PEEK</span></code></td>

</tr></table>

<br>
<pre><span class="keyword">val</span> <a name="VALreceive_message"></a>receive_message : <code class="type">?flags:<a href="Cash.html#TYPEmsg_flag">msg_flag</a> list -> <a href="Cash.html#TYPEsocket">socket</a> -> int -> string * <a href="Cash.html#TYPEsockaddr">sockaddr</a></code></pre><pre><span class="keyword">val</span> <a name="VALreceive_message_bang"></a>receive_message_bang : <code class="type">?start:int -><br>       ?end_:int -><br>       ?flags:<a href="Cash.html#TYPEmsg_flag">msg_flag</a> list -> <a href="Cash.html#TYPEsocket">socket</a> -> string -> int * <a href="Cash.html#TYPEsockaddr">sockaddr</a></code></pre><pre><span class="keyword">val</span> <a name="VALreceive_message_partial"></a>receive_message_partial : <code class="type">?flags:<a href="Cash.html#TYPEmsg_flag">msg_flag</a> list -> <a href="Cash.html#TYPEsocket">socket</a> -> int -> string * <a href="Cash.html#TYPEsockaddr">sockaddr</a></code></pre><pre><span class="keyword">val</span> <a name="VALreceive_message_bang_partial"></a>receive_message_bang_partial : <code class="type">?start:int -><br>       ?end_:int -><br>       ?flags:<a href="Cash.html#TYPEmsg_flag">msg_flag</a> list -> <a href="Cash.html#TYPEsocket">socket</a> -> string -> int * <a href="Cash.html#TYPEsockaddr">sockaddr</a></code></pre><pre><span class="keyword">val</span> <a name="VALsend_message"></a>send_message : <code class="type">?start:int -><br>       ?end_:int -><br>       ?flags:<a href="Cash.html#TYPEmsg_flag">msg_flag</a> list -><br>       ?sockaddr:<a href="Cash.html#TYPEsockaddr">sockaddr</a> -> <a href="Cash.html#TYPEsocket">socket</a> -> string -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsend_message_partial"></a>send_message_partial : <code class="type">?start:int -><br>       ?end_:int -><br>       ?flags:<a href="Cash.html#TYPEmsg_flag">msg_flag</a> list -><br>       ?sockaddr:<a href="Cash.html#TYPEsockaddr">sockaddr</a> -> <a href="Cash.html#TYPEsocket">socket</a> -> string -> int</code></pre><br>
For most uses, standard input and output routines such as <code class="code">read_string</code> and
<code class="code">write_string</code> should suffice.  However, in some cases an extended interface is
required. The <code class="code">receive_message</code> and <code class="code">send_message</code> calls parallel the
<code class="code">read_string</code> and <code class="code">write_string</code> calls with a similar naming scheme.
<p>

One additional feature of these routines is that <code class="code">receive_message</code> returns the
remote <i>socket-address</i> and <i>send-message</i> takes an optional remote
<code class="code">socket_address</code>. This allows a program to know the source of input from a
datagram socket and to use a datagram socket for output without first connecting
it.
<p>

All of these procedures take an optional <i>~flags</i> field. This argument is a
list of <code class="code">msg_flag</code>'s.
<p>

See <code class="code">read_string_in</code> and <code class="code">write_string</code> for a more detailed description of the
arguments and return values.<br><br>
<br>
<br>
<a name="2_Socketoptions"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Socket options</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
<code class="code">socket_option_...</code> and <code class="code">set_socket_option_...</code> allow the inspection and
modification, respectively, of several options available on sockets. The <i>protocol_level</i> argument specifies what protocol level is to be examined or
affected. A level of <code class="code">SOL_SOCKET</code> specifies the highest possible level that is
available on all socket types. A specific protocol number can also be used as
provided by <code class="code">protocol_info</code>, described below.
<p>

There are several different classes of socket options:<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEsocket_bool_option"></a>socket_bool_option = <code class="type">Unix.socket_bool_option</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_DEBUG</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_BROADCAST</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_REUSEADDR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_KEEPALIVE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_DONTROUTE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_OOBINLINE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_ACCEPTCONN</span></code></td>

</tr></table>

<div class="info">
The first class consists of boolean options which can be either true or
false.<br>
</div>
<br>
<br><code><span class="keyword">type</span> <a name="TYPEsocket_int_option"></a>socket_int_option = <code class="type">Unix.socket_int_option</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_SNDBUF</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_RCVBUF</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_ERROR</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_TYPE</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_RCVLOWAT</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_SNDLOWAT</span></code></td>

</tr></table>

<div class="info">
Value options are another category of socket options. Options of this kind
are an integer value.<br>
</div>
<br>
<br><code><span class="keyword">type</span> <a name="TYPEsocket_optint_option"></a>socket_optint_option = <code class="type">Unix.socket_optint_option</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_LINGER</span></code></td>

</tr></table>

<div class="info">
A third option kind specifies how long for data to linger after a socket has
been closed. There is only one option of this kind. It is set with either <code class="code">None</code>
to disable it or (<code class="code">Some</code> integer) number of seconds to linger and return a value
of the same type upon inspection.<br>
</div>
<br>
<br><code><span class="keyword">type</span> <a name="TYPEsocket_float_option"></a>socket_float_option = <code class="type">Unix.socket_float_option</code> =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_RCVTIMEO</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">SO_SNDTIMEO</span></code></td>

</tr></table>

<div class="info">
The fourth and final option kind of this time is a timeout option. There are
two values of this option, for sending or receiving. These are set with a real
number of microseconds resolution and return a real value upon inspection.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALsocket_option_bool"></a>socket_option_bool : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEprotocol_level">protocol_level</a> -> <a href="Cash.html#TYPEsocket_bool_option">socket_bool_option</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALset_socket_option_bool"></a>set_socket_option_bool : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEprotocol_level">protocol_level</a> -> <a href="Cash.html#TYPEsocket_bool_option">socket_bool_option</a> -> bool -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsocket_option_int"></a>socket_option_int : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEprotocol_level">protocol_level</a> -> <a href="Cash.html#TYPEsocket_int_option">socket_int_option</a> -> int</code></pre><pre><span class="keyword">val</span> <a name="VALset_socket_option_int"></a>set_socket_option_int : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEprotocol_level">protocol_level</a> -> <a href="Cash.html#TYPEsocket_int_option">socket_int_option</a> -> int -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsocket_option_optint"></a>socket_option_optint : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEprotocol_level">protocol_level</a> -> <a href="Cash.html#TYPEsocket_optint_option">socket_optint_option</a> -> int option</code></pre><pre><span class="keyword">val</span> <a name="VALset_socket_option_optint"></a>set_socket_option_optint : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -><br>       <a href="Cash.html#TYPEprotocol_level">protocol_level</a> -> <a href="Cash.html#TYPEsocket_optint_option">socket_optint_option</a> -> int option -> unit</code></pre><pre><span class="keyword">val</span> <a name="VALsocket_option_float"></a>socket_option_float : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -> <a href="Cash.html#TYPEprotocol_level">protocol_level</a> -> <a href="Cash.html#TYPEsocket_float_option">socket_float_option</a> -> float</code></pre><pre><span class="keyword">val</span> <a name="VALset_socket_option_float"></a>set_socket_option_float : <code class="type"><a href="Cash.html#TYPEsocket">socket</a> -><br>       <a href="Cash.html#TYPEprotocol_level">protocol_level</a> -> <a href="Cash.html#TYPEsocket_float_option">socket_float_option</a> -> float -> unit</code></pre><br>
<br>
<a name="2_Databaseinformationentries"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Database-information entries</span>
</div>
</td>
</tr>
</table>
<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEherror"></a>herror =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">HOST_NOT_FOUND</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">TRY_AGAIN</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">NO_RECOVERY</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">NO_DATA</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">NO_ADDRESS</span></code></td>

</tr></table>

<div class="info">
<code class="code">host_info_...</code> could fail and raise the following error for one of these
reasons.<br>
</div>
<br>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONNetdb_error"></a>Netdb_error <span class="keyword">of</span> <code class="type"><a href="Cash.html#TYPEherror">herror</a></code></pre>
<br><code><span class="keyword">type</span> <a name="TYPEhost_info"></a>host_info = <code class="type">Unix.host_entry</code> = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>h_name&nbsp;: <code class="type">string</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Host name.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>h_aliases&nbsp;: <code class="type">string array</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Alternative names.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>h_addrtype&nbsp;: <code class="type"><a href="Cash.html#TYPEprotocol_family">protocol_family</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>h_addr_list&nbsp;: <code class="type"><a href="Cash.html#TYPEinet_addr">inet_addr</a> array</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Host addresses.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
<code class="code">host_info_...</code> return a value of this type.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALhost_info_name"></a>host_info_name : <code class="type">string -> <a href="Cash.html#TYPEhost_info">host_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALhost_info_addr"></a>host_info_addr : <code class="type"><a href="Cash.html#TYPEsockaddr">sockaddr</a> -> <a href="Cash.html#TYPEhost_info">host_info</a></code></pre><div class="info">
<code class="code">host_info_...</code> allow a program to look up a host entry based on either its
string <i>name</i> or <i>socket_address</i>.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEnetwork_info"></a>network_info = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>n_name&nbsp;: <code class="type">string</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Network name.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>n_aliases&nbsp;: <code class="type">string array</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Alternative names.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>n_addrtype&nbsp;: <code class="type"><a href="Cash.html#TYPEprotocol_family">protocol_family</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>n_net&nbsp;: <code class="type">int32</code>;</code></td>

</tr></table>
}

<div class="info">
<code class="code">network_info_...</code> return a value of this type.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALnetwork_info_name"></a>network_info_name : <code class="type">string -> <a href="Cash.html#TYPEnetwork_info">network_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALnetwork_info_addr"></a>network_info_addr : <code class="type"><a href="Cash.html#TYPEsockaddr">sockaddr</a> -> <a href="Cash.html#TYPEnetwork_info">network_info</a></code></pre><div class="info">
<code class="code">network_info_...</code> allow a program to look up a network entry based on
either its string <i>name</i> or <i>socket_address</i>.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEservice_info"></a>service_info = <code class="type">Unix.service_entry</code> = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>s_name&nbsp;: <code class="type">string</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Service name.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>s_aliases&nbsp;: <code class="type">string array</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Alternative names.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>s_port&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Port number.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>s_proto&nbsp;: <code class="type">string</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Protocol name.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
<code class="code">service_info_...</code> return a value of this type.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALservice_info_name"></a>service_info_name : <code class="type">?protocol:string -> string -> <a href="Cash.html#TYPEservice_info">service_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALservice_info_port"></a>service_info_port : <code class="type">?protocol:string -> int -> <a href="Cash.html#TYPEservice_info">service_info</a></code></pre><div class="info">
<code class="code">service_info_...</code> allow a program to look up a service entry based on
either its string <i>name</i> or integer <i>port</i>.<br>
</div>
<br><code><span class="keyword">type</span> <a name="TYPEprotocol_info"></a>protocol_info = <code class="type">Unix.protocol_entry</code> = {<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>p_name&nbsp;: <code class="type">string</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Protocol name.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>p_aliases&nbsp;: <code class="type">string array</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Alternative names.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>p_proto&nbsp;: <code class="type">int</code>;</code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Protocol number.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
<code class="code">protocol_info_...</code> return a value of this type.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALprotocol_info_name"></a>protocol_info_name : <code class="type">string -> <a href="Cash.html#TYPEprotocol_info">protocol_info</a></code></pre><pre><span class="keyword">val</span> <a name="VALprotocol_info_port"></a>protocol_info_port : <code class="type">int -> <a href="Cash.html#TYPEprotocol_info">protocol_info</a></code></pre><div class="info">
<code class="code">protocol_info_...</code> allow a program to look up a protocol entry based on
either its string <i>name</i> or integer <i>port</i>.<br>
</div>
<br>
<br>
<a name="1_Stringsandcharacters"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title1"><td><div align=center>
<span class="title1">Strings and characters</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Strings are the basic communication medium for Unix processes, so a Unix
programming environment must have reasonable facilities for manipulating them.
Cash provides a powerful set of procedures for processing strings and
characters.  Besides the the facilities described in this chapter, Cash also
provides:<ul>
<li><b>Field parsing, delimited record I/O</b> (chapter <a href="Cash.html#record_io_and_field_parsing"><i>Record I/O and field parsing</i></a>).
   These procedures let you read in chunks of text delimited by selected
   characters, and parse each record into fields based on regular expressions
   (for example, splitting a string at every occurrence of colon or
   white-space).</li>
<li><b>The SRFI-13 string libraries.</b>
   This pair of libraries contains procedures that create, fold, iterate over,
   search, compare, assemble, cut, hash, case-map, and otherwise manipulate
   strings.  They are provided by the String_13 and String_13_internals modules,
   and are also available in the default <a href="Cash.html"><code class="code">Cash</code></a> module.  More documentation on
   these procedures can be found at URLs
   <a href="http://srfi.schemers.org/srfi-13/srfi-13.html"> (html)</a> and
   <a href="http://srfi.schemers.org/srfi-13/srfi-13.txt"> (text)</a>.</li>
</ul>
<br><br>
<br>
(Oops: the SRFI-13 libraries are not implemented for now)<ul>
<li><b>The SRFI-14 character-set library</b>.
   This library provides a set-of-characters abstraction, which is frequently
   useful when searching, parsing, filtering or otherwise operating on strings
   and character data. The SRFI is provided by the Charset_14 module; its
   bindings are also available in the default <a href="Cash.html"><code class="code">Cash</code></a> module.
   More documentation on this library can be found at URLs
   <a href="http://srfi.schemers.org/srfi-14/srfi-14.html"> (html)</a> and
   <a href="http://srfi.schemers.org/srfi-14/srfi-14.txt"> (text)</a>.</li>
</ul>
<br><br>
<br>
<br>
<a name="filenames"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Manipulating file names</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
These procedures do not access the file-system at all; they merely operate
on file-name strings. Much of this structure is patterned after the GNU Emacs
design. Perhaps a more sophisticated system would be better, something like the
pathname abstractions of CommonLisp or MIT Scheme. However, being Unix-specific,
we can be a little less general.<br><br>
<br>
<br>
<a name="3_Terminology"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Terminology</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
These procedures carefully adhere to the Posix standard for file-name
resolution, which occasionally entails some slightly odd things.  This section
will describe these rules, and give some basic terminology.
<p>

A <em>file-name</em> is either the file-system root (``/''), or a series of
slash-terminated directory components, followed by a a file component.  Root is
the only file-name that may end in slash.  Some examples:
<pre>  File name            Dir components        File component
  src/des/main.c       ["src"; "des"]        "main.c"
  /src/des/main.c      [""; "src"; "des"]    "main.c"
  main.c               []                    "main.c"</pre>
<p>

Note that the relative filename <b>src/des/main.c</b> and the absolute filename <b>/src/des/main.c</b> are distinguished by the presence of the root component <b>""</b>
in the absolute path.
<p>

Multiple embedded slashes within a path have the same meaning as a single slash.
More than two leading slashes at the beginning of a path have the same meaning
as a single leading slash --- they indicate that the file-name is an absolute one,
with the path leading from root.  However, Posix permits the OS to give special
meaning to <em>two</em> leading slashes.  For this reason, the routines in this
section do not simplify two leading slashes to a single slash.
<p>

A file-name in <em>directory form</em> is either a file-name terminated by a slash,
<i>e.g</i>., ``<b>/src/des/</b>'', or the empty string, ``''.  The empty string
corresponds to the current working directory, whose file-name is dot (``<b>.</b>'').  Working backwards from the append-a-slash rule, we extend the syntax of
Posix file-names to define the empty string to be a file-name form of the root
directory ``<b>/</b>''.  (However, ``<b>/</b>'' is also acceptable as a file-name form
for root.)  So the empty string has two interpretations: as a file-name form, it
is the file-system root; as a directory form, it is the current working
directory.  Slash is also an ambiguous form: <b>/</b> is both a directory-form and
a file-name form.
<p>

The directory form of a file-name is very rarely used.  Almost all of the
procedures in Cash name directories by giving their file-name form (without the
trailing slash), not their directory form.  So, you say ``<b>/usr/include</b>'',
and ``<b>.</b>'', not ``<b>/usr/include/</b>'' and ``''.  The sole exceptions are
<code class="code">file_name_as_directory</code> and <code class="code">directory_as_file_name</code>, whose jobs are to convert
back-and-forth between these forms, and <code class="code">file_name_directory</code>, whose job it is
to split out the directory portion of a file-name.  However, most procedures
that expect a directory argument will coerce a file-name in directory form to
file-name form if it does not have a trailing slash.  Bear in mind that the
ambiguous case, empty string, will be interpreted in file-name form, i.e., as
root.<br><br>
<br>
<br>
<a name="3_Procedures"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Procedures</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALis_file_name_directory"></a>is_file_name_directory : <code class="type">string -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_file_name_non_directory"></a>is_file_name_non_directory : <code class="type">string -> bool</code></pre><div class="info">
These predicates return true if the string is in directory form, or
  file-name form (see the above discussion of these two forms).  Note that they
  both return true on the ambiguous case of empty string, which is both a
  directory (current working directory), and a file name (the file-system root).
<p>

<pre>File name       is_..._directory        is_..._non_directory}
"src/des"       false                   true
"src/des/"      true                    false
"/"             true                    false
"."             false                   true
""              true                    true
</pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_name_as_directory"></a>file_name_as_directory : <code class="type">string -> string</code></pre><div class="info">
Convert a file-name to directory form.
  Basically, add a trailing slash if needed:
<pre><code class="code">   file_name_as_directory "src/des"             =&gt;  "src/des/"
   file_name_as_directory "src/des/"            =&gt;  "src/des/"
</code></pre>
<code class="code">.</code>, <code class="code">/</code>, and <code class="code">""</code> are special:
<pre><code class="code">   file_name_as_directory "."                   =&gt;  ""
   file_name_as_directory "/"                   =&gt;  "/"
   file_name_as_directory ""                    =&gt;  "/"
</code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALdirectory_as_file_name"></a>directory_as_file_name : <code class="type">string -> string</code></pre><div class="info">
Convert a directory to a simple file-name.
  Basically, kill a trailing slash if one is present:
<pre><code class="code">   directory_as_file_name "foo/bar/"            =&gt; "foo/bar"
</code></pre>
<code class="code">/</code> and <code class="code">""</code> are special:
<pre><code class="code">   directory_as_file_name "/"                   =&gt; "/"
   directory_as_file_name ""                    =&gt; "."  (* i.e., the cwd *)
</code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_file_name_absolute"></a>is_file_name_absolute : <code class="type">string -> bool</code></pre><div class="info">
Does <i>fname</i> begin with a root or <code class="code">~</code> component?
  (Recognising <code class="code">~</code> as a home-directory specification is an extension of Posix
  rules.)
<pre><code class="code">   is_file_name_absolute "/usr/shivers"         =&gt; true
   is_file_name_absolute "src/des"              =&gt; false
   is_file_name_absolute "~/src/des"            =&gt; true </code></pre>
Non-obvious case:
<pre><code class="code">   is_file_name_absolute ""                     =&gt; true (* i.e., root *) </code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_name_directory"></a>file_name_directory : <code class="type">string -> string</code></pre><div class="info">
Return the directory component of <i>fname</i> in directory form.
  If the file-name is already in directory form, return it as-is.
<pre><code class="code">   file_name_directory "/usr/bdc"               =&gt; "/usr/"
   file_name_directory "/usr/bdc/"              =&gt; "/usr/bdc/"
   file_name_directory "bdc/.login"             =&gt; "bdc" </code></pre>
Root has no directory component:
<pre><code class="code">   file_name_directory "/"                      =&gt; ""
   file_name_directory ""                       =&gt; "" </code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_name_nondirectory"></a>file_name_nondirectory : <code class="type">string -> string</code></pre><div class="info">
Return non-directory component of fname.
<pre><code class="code">   file_name_nondirectory "/usr/ian"            =&gt; "ian"
   file_name_nondirectory "/usr/ian/"           =&gt; ""
   file_name_nondirectory "ian/.login"          =&gt; ".login"
   file_name_nondirectory "main.c"              =&gt; "main.c"
   file_name_nondirectory ""                    =&gt; ""
   file_name_nondirectory "/"                   =&gt; "/"
</code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALsplit_file_name"></a>split_file_name : <code class="type">string -> string list</code></pre><div class="info">
Split a file-name into its components.
<pre><code class="code">   split_file_name "src/des/main.c"             =&gt; ["src"; "des"; "main.c"]
   split_file_name "/src/des/main.c"            =&gt; [""; "src"; "des"; "main.c"]
   split_file_name "main.c"                     =&gt; ["main.c"]
   split_file_name "/"                          =&gt; [""]
</code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_name_of_path_list"></a>file_name_of_path_list : <code class="type">?dir:string -> string list -> string</code></pre><div class="info">
Inverse of split_file_name.
<pre><code class="code">   file_name_of_path_list ["src"; "des"; "main.c"] =&gt; "src/des/main.c"
   file_name_of_path_list [""; "src"; "des"; "main.c"] =&gt; "/src/des/main.c"
</code></pre>
Optional <i>~dir</i> arg anchors relative path-lists:
<pre><code class="code">   file_name_of_path_list ~dir:"/usr/shivers" ["src"; "des"; "main.c"]
                                                =&gt; "/usr/shivers/src/des/main.c"
</code></pre>
The optional <i>~dir</i> argument is usefully <code class="code">(cwd ())</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_name_extension"></a>file_name_extension : <code class="type">string -> string</code></pre><div class="info">
Return the file-name's extension.
<pre><code class="code">   file_name_extension "main.c"                 =&gt; ".c"
   file_name_extension "main.c.old"             =&gt; ".old"
   file_name_extension "/usr/shivers"           =&gt; ""
</code></pre>
Weird cases:
<pre><code class="code">   file_name_extension "foo."                   =&gt; "."
   file_name_extension "foo.."                  =&gt; "."
</code></pre>
Dot files are not extensions:
<pre><code class="code">   file_name_extension ".login"                 =&gt; "" </code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALfile_name_sans_extension"></a>file_name_sans_extension : <code class="type">string -> string</code></pre><div class="info">
Return everything but the extension.
<pre><code class="code">   file_name_sans_extension "main.c"            =&gt; "main"
   file_name_sans_extension "main.c.old"        =&gt; "main.c"
   file_name_sans_extension "/usr/shivers"      =&gt; "/usr/shivers"
</code></pre>
Weird cases:
<pre><code class="code">   file_name_sans_extension "foo."              =&gt; "foo"
   file_name_sans_extension "foo.."             =&gt; "foo."
</code></pre>
Dot files are not extensions:
<pre><code class="code">   file_name_sans_extension "/usr/shivers/.login" =&gt; "/usr/shivers/.login" </code></pre>
Note that appending the results of <code class="code">file_name_extension</code> and
<code class="code">file_name_sans_extension</code> in all cases produces the original file-name.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALparse_file_name"></a>parse_file_name : <code class="type">string -> string * string * string</code></pre><div class="info">
Let <i>f</i> be <code class="code">file_name_nondirectory</code> <i>fname</i>.  This function returns the
  three values:<ul>
<li><code class="code">file_name_directory</code> <i>fname</i></li>
<li><code class="code">file_name_sans_extension</code> <i>f</i></li>
<li><code class="code">file_name_extension</code> <i>f</i></li>
</ul>

The inverse of <code class="code">parse_file_name</code>, in all cases, is <code class="code">String.concat ""</code>.
The boundary case of <code class="code">/</code> was chosen to preserve this inverse.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALreplace_extension"></a>replace_extension : <code class="type">string -> string -> string</code></pre><div class="info">
<code class="code">replace_extension</code> <i>fname</i> <i>ext</i> replaces <i>fname</i>'s extension with <i>ext</i>.
  It is exactly equivalent to:
<p>

  <code class="code">(file_name_sans_extension</code> <i>fname</i> <code class="code">) ^</code> <i>ext</i><br>
</div>
<pre><span class="keyword">val</span> <a name="VALsimplify_file_name"></a>simplify_file_name : <code class="type">string -> string</code></pre><div class="info">
Removes leading and internal occurrences of dot.
    A trailing dot is left alone, as the parent could be a symlink.  Removes
    internal and trailing double-slashes.  A leading double-slash is left alone,
    in accordance with Posix.  However, triple and more leading slashes are
    reduced to a single slash, in accordance with Posix.  Double-dots (parent
    directory) are left alone, in case they come after symlinks or appear in a
    <code class="code">/../</code><i>machine</i><code class="code">/...</code> ``super-root'' form (which Posix permits).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALresolve_file_name"></a>resolve_file_name : <code class="type">?dir:string -> string -> string</code></pre><div class="info">
<ul>
<li>Do <code class="code">~</code> expansion.</li>
<li>If <i>~dir</i> is given, convert a relative file-name to an absolute file-name,
  relative to directory <i>~dir</i>.</li>
</ul>
<br>
</div>
<pre><span class="keyword">val</span> <a name="VALexpand_file_name"></a>expand_file_name : <code class="type">?dir:string -> string -> string</code></pre><div class="info">
Resolve and simplify the file-name.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALabsolute_file_name"></a>absolute_file_name : <code class="type">?dir:string -> string -> string</code></pre><div class="info">
<code class="code">absolute_file_name ~dir:</code><i>dir</i> <i>fname</i> converts file-name <i>fname</i>
into an absolute file name, relative to directory <i>~dir</i>, which defaults to
the current working directory. The file name is simplified before being
returned.
<p>

This procedure does not treat a leading tilde character specially.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALhome_dir"></a>home_dir : <code class="type">?user:string -> unit -> string</code></pre><div class="info">
Returns <i>~user</i>'s home directory. <i>~user</i> defaults to the current user.
<pre><code class="code">   home_dir ()                                  =&gt; "/user1/lecturer/shivers"
   home_dir ~user:"ctkwan"                      =&gt; "/user0/research/ctkwan"
</code></pre><br>
</div>
<pre><span class="keyword">val</span> <a name="VALhome_file"></a>home_file : <code class="type">?user:string -> string -> string</code></pre><div class="info">
Returns file-name <i>fname</i> relative to <i>~user</i>'s home directory;
<i>~user</i> defaults to the current user.
<pre><code class="code">   home_file "man"                              =&gt; "/usr/shivers/man"
   home_file ~user:"fcmlau" "man"               =&gt; "/usr/fcmlau/man"
</code></pre><br>
</div>
<br>
The general <code class="code">substitute_env_vars</code> string procedure, defined in the next
section, is also frequently useful for expanding file-names.<br><br>
<br>
<br>
<a name="3_Otherstringmanipulationfacilities"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Other string manipulation facilities</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALsubstitute_env_vars"></a>substitute_env_vars : <code class="type">string -> string</code></pre><div class="info">
Replace occurrences of environment variables with their values.
  An environment variable is denoted by a dollar sign followed by alphanumeric
  chars and underscores, or is surrounded by braces.
<pre><code class="code">   substitute_env_vars "$USER/.login"           =&gt; "shivers/.login"
   substitute_env_vars "${USER}_log"            =&gt; "shivers_log" </code></pre><br>
</div>
<br>
The four next procedures are convenience alternatives to the <code class="code">String</code> ones.<br><br>
<pre><span class="keyword">val</span> <a name="VALindex"></a>index : <code class="type">?from:int -> string -> char -> int option</code></pre><div class="info">
This is like <code class="code">String.index</code> and <code class="code">String.index_from</code> altogether (<i>~from</i>
  defaults to 0), but it never raises <code class="code">Not_found</code>: instead, it packages their
  result in an option type; (note: you can use <code class="code">Env_3_11.internal_index</code> to get
  -1 if the char is not found).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrindex"></a>rindex : <code class="type">?from:int -> string -> char -> int option</code></pre><div class="info">
Same with <code class="code">rindex</code> (and <code class="code">Env_3_11.internal_rindex</code>); <i>~from</i> defaults to
  the length of the string.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsubstring"></a>substring : <code class="type">string -> int -> int -> string</code></pre><div class="info">
This is like <code class="code">String.sub</code> but uses two indices in the string, instead of
  the start position and the length to search. <i>This is gratuitous Scheme
  compatibility.</i><br>
</div>
<pre><span class="keyword">val</span> <a name="VALxsubstring"></a>xsubstring : <code class="type">string -> int -> int -> string</code></pre><div class="info">
This eXtended substring accepts negative indices, meaning to count from the
  end of the string: -1 is the last char, so xsubstring s (-2) (-1) extracts the
  last char.  If you look at the indices as being between the characters, 0 is
  before the first one, and -1 after the last.<br>
</div>
<br>
<br>
<a name="3_Characterpredicates"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Character predicates</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALis_letter"></a>is_letter : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_lower_case"></a>is_lower_case : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_upper_case"></a>is_upper_case : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_title_case"></a>is_title_case : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_digit"></a>is_digit : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_letter_or_digit"></a>is_letter_or_digit : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_graphic"></a>is_graphic : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_printing"></a>is_printing : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_whitespace"></a>is_whitespace : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_blank"></a>is_blank : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_iso_control"></a>is_iso_control : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_punctuation"></a>is_punctuation : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_hex_digit"></a>is_hex_digit : <code class="type">char -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_ascii"></a>is_ascii : <code class="type">char -> bool</code></pre><br>
Each of these predicates tests for membership in one of the standard
character sets provided by the SRFI-14 character-set library (module
Charset_14).  Additionally, the following redundant bindings are provided for
R5RS compatibility:<br><br>
<pre><span class="keyword">val</span> <a name="VALis_alphabetic"></a>is_alphabetic : <code class="type">char -> bool</code></pre><div class="info">
== is_letter_or_digit.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_alphanumeric"></a>is_alphanumeric : <code class="type">char -> bool</code></pre><div class="info">
== is_letter_or_digit.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_numeric"></a>is_numeric : <code class="type">char -> bool</code></pre><div class="info">
== is_digit.<br>
</div>
<br>
<br>
<a name="rdelim"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title1"><td><div align=center>
<span class="title1">Reading delimited strings</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Cash provides a set of procedures that read delimited strings from input
channels.  There are procedures to read a single line of text (terminated by a
newline character), a single paragraph (terminated by a blank line), and general
delimited strings (terminated by a character belonging to an arbitrary character
set).
<p>

All of the delimited input operations described below take a <code class="code">handle_delim</code>
parameter, which determines what the procedure does with the terminating
delimiter character.  There are three plus one possible choices for a
<code class="code">handle_delim</code> parameter:<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEhandle_delim"></a>handle_delim =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Trim</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Peek</span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Concat</span></code></td>

</tr></table>

<br>
<br>
The fourth option is to use a ..._split version of the procedure, that
  return delimiter as second value (so the return type is not compatible with
  the standard version).
<p>

The first case, <code class="code">Trim</code>, is the standard default for all the routines described
in this section.  The last three cases allow the programmer to distinguish
between strings that are terminated by a delimiter character, and strings that
are terminated by an end-of-file.<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEtermination_kind"></a>termination_kind =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Eof</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Read terminated by end of file</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Read</span> <span class="keyword">of</span> <code class="type">char</code></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Read terminated by this delimiter</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Full_buffer</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Filled buffer without finding a delimiter</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Type of the second value returned by <a href="Cash.html#VALlow_read_delimited_bang"><code class="code">low_read_delimited_bang</code></a> and
  the ..._split procedures.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALread_line"></a>read_line : <code class="type">?handle_newline:<a href="Cash.html#TYPEhandle_delim">handle_delim</a> -> Pervasives.in_channel -> string</code></pre><div class="info">
Reads and returns one line of text; on eof, raises End_of_file.
  A line is terminated by newline or eof.
<p>

  <i>handle_newline</i> determines what <code class="code">read_line</code> does with the newline or EOF
  that terminates the line; it defaults to <code class="code">Trim</code> (discard the newline).  Using
  this argument allows one to tell whether or not the last line of input in a
  file is newline terminated.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALread_line_split"></a>read_line_split : <code class="type">Pervasives.in_channel -> string * <a href="Cash.html#TYPEtermination_kind">termination_kind</a></code></pre><div class="info">
Same as <code class="code">read_line</code>, but returns separately the line and the delimiter
   (maybe <code class="code">Eof</code>).  <code class="code">Full_buffer</code> can't happen.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALread_paragraph"></a>read_paragraph : <code class="type">?handle_delim:<a href="Cash.html#TYPEhandle_delim">handle_delim</a> -> Pervasives.in_channel -> string</code></pre><pre><span class="keyword">val</span> <a name="VALread_paragraph_split"></a>read_paragraph_split : <code class="type">Pervasives.in_channel -> string * string</code></pre><div class="info">
These procedures skip blank lines, then read text from a channel until a
  blank line or eof is found.  A ``blank line'' is a (possibly empty) line
  composed only of white space.  The <i>~handle_delim</i> parameter (or using
  <code class="code">read_paragraph_split</code>) determines how the terminating blank line is handled.
  It is described above, and defaults to <code class="code">Trim</code>.  The <code class="code">Peek</code> option is not
  available.<br>
</div>
<br>
The following procedures read in strings from channels delimited by
characters belonging to a specific set.  See the
<a href="http://srfi.schemers.org/srfi-14/srfi-14.html">character set library
specification</a> for information on character set manipulation.<br><br>
<pre><span class="keyword">val</span> <a name="VALread_delimited"></a>read_delimited : <code class="type">?chan:Pervasives.in_channel -><br>       ?handle_delim:<a href="Cash.html#TYPEhandle_delim">handle_delim</a> -> Charset_14.any_t -> string</code></pre><pre><span class="keyword">val</span> <a name="VALread_delimited_split"></a>read_delimited_split : <code class="type">?chan:Pervasives.in_channel -><br>       Charset_14.any_t -> string * <a href="Cash.html#TYPEtermination_kind">termination_kind</a></code></pre><div class="info">
Read until we encounter one of the chars in <i>charset</i> or eof.
    The <i>~handle_delim</i> parameter (or using <code class="code">read_delimited_split</code>) determines
    how the terminating character is handled. It is described above, and
    defaults to <code class="code">Trim</code>.
<p>

    The <i>char_set</i> argument may be a charset, a string, a character, or a
    character predicate; it is coerced to a charset.
<p>

    <code class="code">Full_buffer</code> can't happen to <code class="code">read_delimited_split</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALread_delimited_bang"></a>read_delimited_bang : <code class="type">?chan:Pervasives.in_channel -><br>       ?handle_delim:<a href="Cash.html#TYPEhandle_delim">handle_delim</a> -><br>       ?start:int -> ?end_:int -> Charset_14.any_t -> string -> int option</code></pre><pre><span class="keyword">val</span> <a name="VALread_delimited_bang_split"></a>read_delimited_bang_split : <code class="type">?chan:Pervasives.in_channel -><br>       ?start:int -><br>       ?end_:int -><br>       Charset_14.any_t -> string -> (int * <a href="Cash.html#TYPEtermination_kind">termination_kind</a>) option</code></pre><div class="info">
Side-effecting variants of <code class="code">read_delimited</code>.
<p>

    The data is written into the string <i>buf</i> at the indices in the half-open
    interval [<i>start,end_</i>); the default interval is the whole string: <i>    start</i> = 0 and <i>end_</i> = (<code class="code">String.length</code> <i>buf</i>).  The values of <i>    start</i> and <i>end_</i> must specify a well-defined interval in <i>str</i>, i.e., 0
    &lt;= <i>start</i> &lt;= <i>end_</i> &lt;= (<code class="code">String.length</code> <i>buf</i>).
<p>

    <code class="code">read_delimited_bang</code> returns <code class="code">Some</code> <i>nbytes</i>, the number of bytes
    read. If the buffer filled up without a delimiter character being found,
    <code class="code">None</code> is returned. If the channel is at eof when the read starts,
    End_of_file is raised.
<p>

    If the read is successfully terminated by reading a delimiter character (<i>    i.e.,</i> <code class="code">read_delimited_bang</code> returns <code class="code">Some</code> integer, or
    <code class="code">read_delimited_bang_split</code> returns (<i>n</i>, <code class="code">Char</code> <i>c</i>), then the <i>    ~handle_delim</i> parameter (or using <code class="code">read_delimited_bang_split</code>) determines
    how the terminating character is handled.  It is described above, and
    defaults to <code class="code">Trim</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlow_read_delimited_bang"></a>low_read_delimited_bang : <code class="type">?chan:Pervasives.in_channel -><br>       ?start:int -><br>       ?end_:int -><br>       Charset_14.any_t -><br>       string -> <a href="Cash.html#TYPEhandle_delim">handle_delim</a> -> <a href="Cash.html#TYPEtermination_kind">termination_kind</a> * int</code></pre><div class="info">
This low-level delimited reader uses an alternate interface.
It returns two values: <i>terminator</i> and <i>num_read</i>.<ul>
<li><i>terminator</i>: A <code class="code">termination_kind</code> value describing why the read was terminated.</li>
<li><i>num_read</i>: Number of characters read into <i>buf</i>.</li>
</ul>

If the read is successfully terminated by reading a delimiter character, then
the <i>handle_delim</i> parameter determines what to do with the terminating
character.  If <code class="code">Peek</code>, the character is left in the input stream where a
subsequent read operation will retrieve it; else the character is removed from
the input stream: if <code class="code">Trim</code>, it is not copied in the buffer; if <code class="code">Concat</code>, it is
put in the buffer.  In either case, the character is also the first value
returned by the procedure call.
<p>

Invariants:<ul>
<li><i>terminator</i> = <code class="code">Full_buffer</code> =&gt; <i>num_read = end_ - start</i>.</li>
<li><i>terminator</i> = <code class="code">Eof</code> and <i>num_read</i> = 0 =&gt; at EOF.</li>
</ul>
<br>
</div>
<pre><span class="keyword">val</span> <a name="VALskip_char_set"></a>skip_char_set : <code class="type">?chan:Pervasives.in_channel -> Charset_14.any_t -> int</code></pre><div class="info">
<code class="code">skip_char_set</code> <i>skip_chars</i> skips characters occurring in the set <i>  skip_chars</i>, and returns the number of characters skipped.  The <i>skip_chars</i>
  argument may be a charset, a string, a character, or a character predicate; it
  is coerced to a charset.<br>
</div>
<br>
<br>
<a name="record_io_and_field_parsing"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title1"><td><div align=center>
<span class="title1">Record I/O and field parsing</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Unix programs frequently process streams of records, where each record is
delimited by a newline, and records are broken into fields with other delimiters
(for example, the colon character in <code class="code">/etc/passwd</code>).  Cash has procedures that
allow the programmer to easily do this kind of processing.  Cash's field parsers
can also be used to parse other kinds of delimited strings, such as
colon-separated <code class="code">$PATH</code> lists.<br><br>
<br>
The procedures in this section are used to read records from I/O streams and
parse them into fields.  A record is defined as text terminated by some
delimiter (usually a newline).  A record can be split into fields by using
regular expressions in one of several ways: to <em>match</em> fields, to <em>separate</em>
fields, or to <em>terminate</em> fields.  The field parsers can be applied to
arbitrary strings (one common use is splitting environment variables such as
<code class="code">$PATH</code> at colons into its component elements).
<p>

The general delimited-input procedures described in chapter <a href="Cash.html#rdelim"><i>Reading delimited strings</i></a> are
also useful for reading simple records, such as single lines, paragraphs of
text, or strings terminated by specific characters.<br><br>
<br>
<br>
<a name="2_Readingrecords"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Reading records</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALrecord_reader"></a>record_reader : <code class="type">?delims:Charset_14.any_t -><br>       ?elide_delims:bool -><br>       ?handle_delim:Delim_7.handle_delim -> unit -> Pervasives.in_channel -> string</code></pre><pre><span class="keyword">val</span> <a name="VALrecord_reader_split"></a>record_reader_split : <code class="type">?delims:Charset_14.any_t -><br>       ?elide_delims:bool -> unit -> Pervasives.in_channel -> string * string</code></pre><div class="info">
<code class="code">record_reader</code> <i>~delims ~elide_delims ~handle_delim</i> <code class="code">()</code> returns a
 procedure that reads records from a channel.
<p>

A record is a sequence of characters terminated by one of the characters in <i>delims</i> or eof.  The <i>delims</i> set defaults to the set {'\n'}.  It may be a
charset, string, character, or character predicate, and is coerced to a charset.
<p>

If <i>elide_delims</i> is <code class="code">true</code>, then a contiguous sequence of delimiter chars are
taken as a single record delimiter.  If <i>elide_delims</i> is <code class="code">false</code> (the
default), then a delimiter char coming immediately after a delimiter char
produces an empty-string record. The reader consumes the delimiting char(s)
before returning from a read.
<p>

The <i>handle_delim</i> argument (or using <code class="code">record_reader_split</code>) controls what is
done with the record's terminating delimiter.  It has the same meaning as for
the procedures of chapter <a href="Cash.html#rdelim"><i>Reading delimited strings</i></a>, except there is no Peek option:<ul>
<li><code class="code">Trim</code>: Delimiters are trimmed (the default).</li>
<li><code class="code">Concat</code>:  The record and its delimiter are returned as a single string.</li>
</ul>

When using <code class="code">record_reader_split</code>, the reader returns delimiter string as a
second argument. If record is terminated by EOF, then the null string is
returned as this second argument.
<p>

The reader procedure returned takes one argument, the channel from which to
read. It returns a string or raises <code class="code">End_of_file</code>.
<p>

To emphasize that these procedures are normally used to make a reader procedure,
they take a unit argument after the optionals, which is not necessary from a
strict typing point of view.  It's easier to write:
<pre><code class="code">    let read = record_reader ~handle_delim:Concat () </code></pre>
than be forced to use:
<pre><code class="code">    let read = record_reader ?delims:None ?elide_delims:None ~handle_delim:Concat </code></pre>
<p>

Moreover, <code class="code">record_reader</code> does a non-trivial amount of work to make a faster
reader procedure; it is not efficient to use <code class="code"> record_reader () channel </code> in a
tight loop --- this would be even less noticeable if one could write
<code class="code">record_reader channel</code>.<br>
</div>
<br>
<br>
<a name="field_splitter"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Parsing fields</span>
</div>
</td>
</tr>
</table>
<br><br>
<br><code><span class="keyword">type</span> <a name="TYPEhandle_field_delim"></a>handle_field_delim =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Trim_f</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Delimiters are thrown away after parsing (default).</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Split_f</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Delimiters are appended to the field preceding them.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Concat_f</span></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>Delimiters are returned as separate elements in the field list.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
Another handle_delim type reserved for field spliting.<br>
</div>
<br>
<br><code><span class="keyword">type</span> <a name="TYPEdelim_matcher"></a>delim_matcher =<br></code><table border="0" cellpadding="1">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Match_proc</span> <span class="keyword">of</span> <code class="type">(string -> int -> int * int)</code></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>A function of a string, searching from an int position, that returns
      the offsets of the next match, <i>i.e</i>, the indices of its first
      character, and of the first character following it.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">String</span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>A litteral string.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Charset</span> <span class="keyword">of</span> <code class="type">Charset_14.any_t</code></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>A Charset.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Regexp</span> <span class="keyword">of</span> <code class="type">Pcre.regexp</code></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>A compiled regexp.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Pattern</span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td align="left" valign="top" ><code>(*</code></td><td align="left" valign="top" ><code>The string denotation of a regexp.</code></td><td align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info">
The many ways to specify how to match fields or delimiters.<br>
</div>
<br>
<pre><span class="keyword">val</span> <a name="VALfield_splitter"></a>field_splitter : <code class="type">?field:<a href="Cash.html#TYPEdelim_matcher">delim_matcher</a> -><br>       ?num_fields:int -> unit -> ?start:int -> string -> string list</code></pre><pre><span class="keyword">val</span> <a name="VALinfix_splitter"></a>infix_splitter : <code class="type">?delim:<a href="Cash.html#TYPEdelim_matcher">delim_matcher</a> -><br>       ?num_fields:int -><br>       ?handle_delim:<a href="Cash.html#TYPEhandle_field_delim">handle_field_delim</a> -><br>       unit -> ?start:int -> string -> string list</code></pre><pre><span class="keyword">val</span> <a name="VALsuffix_splitter"></a>suffix_splitter : <code class="type">?delim:<a href="Cash.html#TYPEdelim_matcher">delim_matcher</a> -><br>       ?num_fields:int -><br>       ?handle_delim:<a href="Cash.html#TYPEhandle_field_delim">handle_field_delim</a> -><br>       unit -> ?start:int -> string -> string list</code></pre><pre><span class="keyword">val</span> <a name="VALsloppy_suffix_splitter"></a>sloppy_suffix_splitter : <code class="type">?delim:<a href="Cash.html#TYPEdelim_matcher">delim_matcher</a> -><br>       ?num_fields:int -><br>       ?handle_delim:<a href="Cash.html#TYPEhandle_field_delim">handle_field_delim</a> -><br>       unit -> ?start:int -> string -> string list</code></pre><div class="info">
These functions return a parser function that can be used as follows:
<pre><code class="code">    parser ~start string            =&gt; string list </code></pre>
<p>

The returned parsers split strings into fields defined by regular expressions.
You can parse by specifying a pattern that <em>separates</em> fields, a pattern that
<em>terminates</em> fields, or a pattern that <em>matches</em> fields: <ul>
<li><code class="code">field_splitter</code>: matches fields</li>
<li><code class="code">infix_splitter</code>: separates fields</li>
<li><code class="code">suffix_splitter</code>: terminates fields</li>
<li><code class="code">sloppy_suffix_splitter</code>: terminates fields</li>
</ul>

These parser generators are controlled by a range of options, so that you can
precisely specify what kind of parsing you want. However, these options default
to reasonable values for general use.
<p>

Defaults:<ul>
<li><i>~num_fields</i>: none (as many fields as possible)</li>
<li><i>~handle_delim</i>: <code class="code">Trim_f</code> (discard delimiter chars)</li>
<li><i>~field, ~delim</i>: bindings are explicitly available...</li>
</ul>
<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdefault_field_matcher"></a>default_field_matcher : <code class="type"><a href="Cash.html#TYPEdelim_matcher">delim_matcher</a></code></pre><div class="info">
The default value of <i>~field</i> arg to <code class="code">field_splitter</code>: "\S+"
  (non-white-space).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdefault_infix_matcher"></a>default_infix_matcher : <code class="type"><a href="Cash.html#TYPEdelim_matcher">delim_matcher</a></code></pre><div class="info">
The default value of <i>~delim</i> arg to <code class="code">infix_splitter</code>: "\s+" (white space)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdefault_suffix_matcher"></a>default_suffix_matcher : <code class="type"><a href="Cash.html#TYPEdelim_matcher">delim_matcher</a></code></pre><div class="info">
The default value of <i>~delim</i> arg to <code class="code">suffix_splitter</code> and
  <code class="code">sloppy_suffix_splitter</code>: "\s+|\z" (white space or eos)<br>
</div>
<br>
These defaults mean: break the string at white space, discarding the white
  space, and parse as many fields as possible.
<p>

The <i>delim</i> parameter is a regular expression matching the text that occurs
between fields.  In the separator case, it defaults to a pattern matching white
space; in the terminator case, it defaults to white space or end-of-string.
<p>

The <i>field</i> parameter is a regular expression used to match fields. It
defaults to non-white-space.
<p>

The <i>delim</i> patterns may be given as a matching procedure, a litteral string,
a charset, an un-compiled regexp pattern, which are all coerced to compiled
regular expressions.  So the following expressions are all equivalent, each
producing a function that splits strings apart at colons:
<pre><code class="code">
    infix_splitter ~delim:(String ":") ();
    infix_splitter ~delim:(Charset_14.of_string ":") ();
    infix_splitter ~delim:(Regexp (Pcre.regexp ":")) ();
    infix_splitter ~delim:(Pattern ":") ();
    infix_splitter
      ~delim:(Match_proc
         (fun s pos -&gt; let i = String.index_from s pos ':' in i, i + 1))
      ();;
</code></pre>
<p>

The <i>handle_delim</i> determines what to do with delimiters.  See
<a href="Cash.html#TYPEhandle_field_delim"><code class="code">handle_field_delim</code></a>.
<p>

The <i>num_fields</i> argument used to create the parser specifies how many fields
to parse.  If unspecified, the procedure parses them all.  If a positive integer
<code class="code">n</code>, exactly that many fields are parsed; it is an error if there are more or
fewer than <code class="code">n</code> fields in the record. If <i>num_fields</i> is a negative integer or
zero, then <code class="code">|n|</code> fields are parsed, and the remainder of the string is returned
in the last element of the field list; it is an error if fewer than <code class="code">|n|</code> fields
can be parsed.
<p>

The field parser produced is a procedure that can be employed as follows:
<pre><code class="code">     parse ~start string            =&gt; string list </code></pre>
The optional <i>start</i> argument (default 0) specifies where in the string to
begin the parse. It is an error if <i>start</i> <code class="code">&gt; String.length</code> <i>string</i>.<br><br>
<br>
The parsers returned by the four parser generators implement different kinds of
field parsing:
<ul>
<li><code class="code">field_splitter</code>: The regular expression specifies the actual field.</li>
<li><code class="code">suffix_splitter</code>: Delimiters are interpreted as element <em>terminators</em>. 
 If vertical-bar is the the delimiter, then the string <code class="code">""</code> is the empty record
 <code class="code">()</code>, <code class="code">"foo|"</code> produces a one-field record <code class="code">("foo")</code>, and <code class="code">"foo"</code> is an error.
 <code class="code">("foo")</code>, and <code class="code">"foo"</code> is an error.
<p>

 The syntax of suffix-delimited records is:
<p>

 <i>&lt;record&gt;</i> <code class="code">::=</code> <i>""</i> (empty record) <code class="code">|</code> <i>&lt;element&gt; &lt;delim&gt; &lt;record&gt;</i>
<p>

 It is an error if a non-empty record does not end with a delimiter.  To make
 the last delimiter optional, make sure the delimiter regexp matches the
 end-of-string (<code class="code">"\z"</code>). </li>
<li><code class="code">infix_splitter</code>: Delimiters are interpreted as element <em>separators</em>. If
 comma is the delimiter, then the string <code class="code">"foo,"</code> produces a two-field record
 <code class="code">("foo" "")</code>.
<p>

 The syntax of infix-delimited records is:
<p>

 <i>&lt;record&gt;</i> <code class="code">::=</code> <i>""</i> (forced to be empty record) <code class="code">|</code> <i>&lt;real-infix-record&gt;</i>
<p>

 <i>&lt;real-infix-record&gt;</i> <code class="code">::=</code>  <i>&lt;element&gt; &lt;delim&gt; &lt;real-infix-record&gt;</i> <code class="code">|</code> <i>&lt;element&gt;</i>
<p>

 Note that separator semantics doesn't really allow for empty records --- the
 straightforward grammar (<i>i.e.</i>, <i>&lt;real-infix-record&gt;</i>) parses an empty
 string as a singleton list whose one field is the empty string, <code class="code">("")</code>, not as
 the empty record <code class="code">()</code>. This is unfortunate, since it means that infix string
 parsing doesn't make <code class="code">^</code> and <code class="code">@</code> isomorphic. For example, with
<pre><code class="code"> let split = infix_splitter ~delim:(String ":") (); </code></pre>
<pre><code class="code">
 split (x ^ ":" ^ y) </code></pre>
 doesn't always equal
<pre><code class="code"> (split x) @ (split y) </code></pre>
 It fails when <i>x</i> or <i>y</i> are the empty string.  Terminator semantics <em> does</em> preserve a similar isomorphism.
<p>

 However, separator semantics is frequently what other Unix software uses, so to
 parse their strings, we need to use it. For example, Unix <code class="code">$PATH</code> lists have
 separator semantics. The path list <code class="code">"/bin:"</code> is broken up into <code class="code">("/bin" "")</code>,
 not <code class="code">("/bin")</code>.  Comma-separated lists should also be parsed this way. </li>
<li><code class="code">sloppy_suffix_splitter</code>: The same as the <code class="code">suffix</code> case, except that the
 parser will skip an initial delimiter string if the string begins with one
 instead of parsing an initial empty field. This can be used, for example, to
 field-split a sequence of English text at white-space boundaries, where the
 string may begin or end with white space, by using regexp:
<pre><code class="code"> "\s+|\z" </code></pre>
 (But you would be better off using <code class="code">field_splitter</code> in this case.)
</li>
</ul>
 
<p>

The next table shows how the different parser grammars split apart the same
strings.  Having to choose between the different grammars requires you to decide
what you want, but at least you can be precise about what you are parsing. Take
fifteen seconds and think it out. Say what you mean; mean what you say.
<p>

<pre>Record            : suffix          :|$ suffix        : infix           non-: field
""                []                []                []                []
":"               [""]              [""]              [""; ""]          []
"foo:"            ["foo"]           ["foo    "]       ["foo"; ""]       ["foo"]
":foo"            error             [""; "foo"]       [""; "foo"]       ["foo"]
"foo:bar"         error             ["foo"; "bar"]    ["foo"; "bar"]    ["foo"; "bar"]</pre><br><br>
<br>
<br>
<a name="3_Fieldreaders"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Field readers</span>
</div>
</td>
</tr>
</table>
<br><br>
<pre><span class="keyword">val</span> <a name="VALfield_reader"></a>field_reader : <code class="type">?field_parser:(?start:int -> string -> string list) -><br>       ?rec_reader:(Pervasives.in_channel -> string) -><br>       unit -> Pervasives.in_channel -> string * string list</code></pre><div class="info">
This utility returns a procedure that reads records with field structure
  from a channel. The reader is used as follows:
<pre><code class="code"> reader channel           =&gt; (raw-record, parsed-record) </code></pre>
<p>

When the reader is applied to an input channel, it reads a record using <i>rec_reader</i>.  This record is parsed with <i>field_parser</i>. These two values ---
the record, and its parsed representation --- are returned as a pair from the
reader.
<p>

When called at eof, the reader raises <code class="code">End_of_file</code>.
<p>

For example, if channel <code class="code">p</code> is open on <code class="code">/etc/passwd</code>, then
 <pre><code class="code"> let field_parser = infix_splitter ~delim:(String ":") ~num_fields:7 () in
 let parse = field_reader ~field_parser () in
 parse p;; </code></pre>
returns two values:
<pre><code class="code">
("dalbertz:mx3Uaqq0:107:22:David Albertz:/users/dalbertz:/bin/csh",
["dalbertz"; "mx3Uaqq0"; "107"; "22"; "David Albertz"; "/users/dalbertz"; "/bin/csh"])
</code></pre> 
<p>

The <i>rec_reader</i> defaults to <code class="code">read_line</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdefault_field_parser"></a>default_field_parser : <code class="type">?start:int -> string -> string list</code></pre><div class="info">
The  default value of the <i>~field_parser</i> argument to <code class="code">field_reader</code>:
  it is <code class="code">field_splitter ()</code>, a parser that picks out sequences of
  non-white-space strings.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALgen_field_reader"></a>gen_field_reader : <code class="type">('a -> 'b) -> ('c -> 'a) -> 'c -> 'a * 'b</code></pre><div class="info">
Although the record reader typically returns a string, and the field-parser
 typically takes a string argument, this is not required. The record reader can
 produce, and the field-parser consume, values of any type. However, the types
 of defaults arguments to <code class="code">field_reader</code> constrain its type.  So you can use
 this alternate version; its standard use is to be partially applied to 2
 arguments, returning a reader like <code class="code">field_reader</code>.  See examples below.<br>
</div>
<br>
Some examples of field_reader:
<pre><code class="code">    (* /etc/passwd reader. *)
    let passwd_reader =
      field_reader ~field_parser:(infix_splitter ~delim:(String ":") ~num_fields:7 ()) ()
      (* wandy:3xuncWdpKhR.:73:22:Wandy Saetan:/usr/wandy:/bin/csh. *)
    ;;
    (* Two ls -l output readers. *)
    let ls_long_reader =
      field_reader ~field_parser:(infix_splitter ~delim:(Pattern "\s+") ~num_fields:8 ()) ()
      (* -rw-r--r--  1 shivers    22880 Sep 24 12:45 scsh.scm *)
    ;;
    let ls_long_with_blanks_in_filenames_reader =
      field_reader ~field_parser:(infix_splitter ~delim:(Pattern "\s+") ~num_fields:(-7) ()) ()
      (* -rw-r--r--  1 shivers        8 Sep 24 12:45 who am I *)
    ;;
    (* Internet hostname reader. *)
    let hostname_reader =
      field_reader ~field_parser:(field_splitter ~field:(Pattern "[^.]+") ()) ()
      (* stat.sinica.edu.tw *)
    ;;
    (* Internet IP address reader. *)
    let numeric_IP_address_reader =
      field_reader ~field_parser:(field_splitter ~field:(Pattern "[^.]+") ~num_fields:4 ()) ()
      (* 18.24.0.241 *)
    ;;
    (* Line of integers. *)
    let parse_num = field_splitter ~field:(Pattern "[-+]?\d+") ();;
    let line_of_ints_reader =
      let field_parser s = List.map int_of_string (parse_num s) in
      gen_field_reader field_parser read_line
      (* 18 24 0 241 *)
    ;;
    (* Same as above. *)
    let another_line_of_ints_reader =
      let read = field_reader ~field_parser:parse_num () in
      fun chan -&gt; let (record, fields) = (read chan) in (record, List.map int_of_string fields)
      (* Yale beat harvard 26 to 7. *)
    ;;
</code></pre><br><br>
<br>
<br>
<a name="3_Forwardprogressguaranteesandemptystringmatches"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title3"><td><div align=center>
<span class="title3">Forward-progress guarantees and empty-string matches</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
A loop that pulls text off a string by repeatedly matching a regexp against
that string can conceivably get stuck in an infinite loop if the regexp matches
the empty string. For example, the regexps <code class="code">"\A"</code>, <code class="code">"\z"</code>, <code class="code">".*"</code>, and
<code class="code">"foo|[^f]*"</code> can all match the empty string.
<p>

The routines in this package that iterate through strings with regular
expressions are careful to handle this empty-string case.  If a regexp matches
the empty string, the next search starts, not from the end of the match (which
in the empty string case is also the beginning --- that's the problem), but from
the next character over.  This is the correct behaviour. Regexps match the
longest possible string at a given location, so if the regexp matched the empty
string at location <i>i</i>, then it is guaranteed it could not have matched a longer
pattern starting with character <i>i</i>. So we can safely begin our search for the
next match at char <i>i + 1</i>.
<p>

With this provision, every iteration through the loop makes some forward
progress, and the loop is guaranteed to terminate.
<p>

This has the effect you want with field parsing. For example, if you split a
string with the empty pattern, you will explode the string into its individual
characters:
<pre><code class="code"> (suffix_splitter ~delim:(String "") ()) "foo"               =&gt; [""; "f"; "o"; "o"] </code></pre>
<p>

However, even though this boundary case is handled correctly, we don't recommend
using it. Say what you mean --- just use a field splitter:
<pre><code class="code"> (field_splitter ~field:(Pattern ".") ()) "foo"               =&gt; ["f"; "o"; "o"] </code></pre><br><br>
<br>
<br>
<a name="1_RunningCash"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title1"><td><div align=center>
<span class="title1">Running Cash</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
There are several different ways to invoke cash.  You can run it as an
interactive Ocaml system, with a standard read-eval-print interaction loop.
<p>

Cash can also be invoked as the interpreter for a shell script by putting a
``<code class="code">#!/usr/local/bin/cash</code>'' line at the top of the shell script.
<p>

Descending a level, it is also possible to compile to byte- or native code, with
or without -custom for byte-code executables.
<p>

This chapter will cover these various ways of invoking cash programs, from
bigger/faster to smaller/slower methods.<br><br>
<br>
<br>
<a name="true_exec"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Making true executables</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
You just use cash as a library.  Standard linking is as follow:
<p>

<code class="code">ocamlc -custom</code> <i>other options</i> <code class="code">unix.cma pcre.cma cash.cma</code> <i>other files</i>
<p>

<code class="code">ocamlopt</code> <i>other options</i> <code class="code">unix.cmxa pcre.cmxa cash.cmxa</code> <i>other files</i>
<p>

This gives fast startup, plus faster execution with ocamlopt.  With ocamlc -g,
and the proper environment variable OCAMLRUNPARAM, you get backtraces.  You can
use ocamldebug.<br><br>
<br>
<br>
<a name="byte_exec"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Making bytecode-only executables</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
You don't link in the runtime system:
<p>

<code class="code">ocamlc</code> <i>other options, no -custom</i> <code class="code">unix.cma pcre.cma cash.cma</code> <i>other files</i>
<p>

Same as byte-code executable of the preceding section <a href="Cash.html#true_exec"><i>Making true executables</i></a>, but the
bytecode executable is smaller, the startup time negligibly longer.  This works
only if none of the libraries used has been compiled with the -custom flag.<br><br>
<br>
<br>
<a name="2_Cashscripts"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Cash scripts</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Caml scripts (so does Cash) use a toplevel to compile on the fly, then
execute source scripts.  You just put an <code class="code">#!/usr/local/bin/cash</code> as the first
line of the source.  This gives you minimal footprint, but you have longer
startup-time because of the compilation to byte-code prior to execution.  As
toplevels don't know how to dump backtraces on unhandled exceptions, you can't
get one this way (see <a href="Cash.html#true_exec"><i>Making true executables</i></a> and <a href="Cash.html#byte_exec"><i>Making bytecode-only executables</i></a>).
<p>

If you're concerned by startup time and disk usage, but don't care of using 2
files for a script, you can make a compromise by doing the following:
You first compile you source to a .cmo
  <code class="code">ocamlc</code> <i>options</i> <code class="code">-c myscript.ml</code>
but you don't link it.  Then you write a wrapper in a file named, say, myscript:
<pre><code class="code">
  #!/usr/local/bin/cash
  #load "myscript.cmo";;
</code></pre>
and you make it executable with:
  <code class="code">chmod +x myscript</code>
<p>

Then you don't get type errors afterwards, don't pay for compilation at each
execution of the script, and link no byte-code caml library, as the toplevel
already has them in -- unix.cma and especially cash.cma aren't that small.<br><br>
<br>
Now we get at OS limits concerning <code class="code">#!</code> lines:
<p>

First, the standard cash toplevel is itself (in the OS terminology) an ocamlrun
script (ocamlrun being termed ``interpreter''), as its first line is a <code class="code">#!</code> line
too.  But generally, Unix/Linux OSes don't allow such ``scripts'' to be used
themselves in another <code class="code">#!</code> line.  The solution to overcome this limit is easy:
make a cash toplevel with -custom, so, by including the ocamlrun executable, it
becomes a true executable to the OS' eyes.
<p>

The second limit is that some Unices truncate the <code class="code">#!</code> line to some ever too
short size, and/or limit the number of arguments that can be added there
(generally no less than one after the ``interpreter'' name) to an ever too small
number, and do so either silently, or with an imprecise error code (./myscript:
No such file or directory, <i>e.g.</i>, though ./myscript does exist).  And you
sometimes need those -unsafe or -w flags to your script.
<p>

There we use a solution from Scsh: the toplevel itself is named cashtop, and we
use a so-called ``trampoline'' to start it, named cash (there are versions with
Camlp4 revised syntax, resp. cashrtop and cashr).  Cash is a true executable, so
a custom toplevel isn't necessary anymore (but can be used to regain some dozens
of ms of startup time).  It doesn't support cashtop options, but use the second
line of the script to gather them.  So if your script starts like this: <pre><code class="code">
  #!/usr/local/bin/cash
  cashtop arguments ...
  !#
</code></pre>
i.e. the 3d line is ``<code class="code">!#\n</code>'', the second line will be parsed as described below,
to make the arguments to cashtop.<br><br>
<br>
<br>
<a name="4_Secondaryargumentsyntax"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title4"><td><div align=center>
<span class="title4">Secondary argument syntax</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
Cash uses a very simple grammar to encode the extra arguments on the second line
of the cash script.  The only special characters are space, tab, newline, and
backslash.
<p>
<ul>
<li>Each space character terminates an argument.  This means that two spaces in a
  row introduce an empty-string argument.</li>
<li>The tab character is not permitted (unless you quote it with the backslash
  character described below).  This is to prevent the insidious bug where you
  believe you have six space characters, but you really have a tab character,
  and <em>vice-versa</em>.</li>
<li>The newline character terminates an argument, like the space character, and
  also terminates the argument sequence.  This means that an empty line parses
  to the singleton list whose one element is the empty string: (<code class="code">""</code>).  The
  grammar doesn't admit the empty list.</li>
<li>The backslash character is the escape character.
    It escapes backslash, space, tab, turning off their special functions, and
    allowing them to be included in arguments.  The Ansi C escape sequences
    (<code class="code">\b</code>, <code class="code">\n</code>, <code class="code">\r</code> and <code class="code">\t</code>) are also supported; these also produce
    argument-constituents -- <code class="code">\n</code> doesn't act like a terminating newline.
    Backslash followed by other chars is not allowed (so we can extend the
    escape-code space later if we like).</li>
</ul>

You have to construct these line-two argument lines carefully.  In particular,
beware of trailing spaces at the end of the line---they'll give you extra
trailing empty-string arguments.  Here's an example:
<pre><code class="code">
#!/bin/interpreter \
foo bar  quux\ yow\end{verbatim}
</code></pre>
would produce the arguments
 <code class="code">["foo"; "bar"; ""; "quux yow"]</code><br><br>
<br>
<br>
<a name="2_Cashswitches"></a>
<table cellpadding=5 cellspacing=5 width="100%">
<tr class="title2"><td><div align=center>
<span class="title2">Cash switches</span>
</div>
</td>
</tr>
</table>
<br><br>
<br>
The cash trampoline takes command-line switches in this format:
<pre><code class="code">
    $ ./cash -help
    Usage: cash [switches] [--] [scriptfile] [arguments]
    switches are:
      -v            tell about syscalls; and don't unlink -c tempfile
      -c &lt;code&gt;     execute code. Several -c allowed. Omit &lt;scriptfile&gt;
      -sfd &lt;num&gt;    like -c, but code is read on file descriptor num
      --            end my switches
      -help  display this list of options
</code></pre>
<p>

In the tradition of sh -c, or sed -e, you can give a program text as one or more
arguments (that are strictly concatenated):
<pre><code class="code">
    $ cash -c 'print_endline "hello world";;'
    hello world
</code></pre>
or even:
<pre><code class="code">
    $ /cash -c 'print_endline "hello' -c ' world";;'
    hello world
</code></pre>
if you understand enough the quoting syntax of your shell.
<p>

You can read a program text from a file descriptor too, by using the -sfd
switch.  For example, to read a script from standard input, use -sfd 0.  You can
use -sfd several times, and mix with -c: all the fragments are concatenated in
the order of the switches.<br><br>
</body></html>